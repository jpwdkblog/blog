{"meta":{"title":"Japan WDK Support Blog","subtitle":"","description":"","author":"jpwdkblog","url":"https://jpwdkblog.github.io/blog"},"pages":[],"posts":[{"title":"Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 2 - デバッガーの接続とデバッグ)","slug":"umdf_remote_debug_part2","date":"2025-09-30T15:00:00.000Z","updated":"2025-10-01T07:16:53.475Z","comments":true,"path":"2025/10/01/umdf_remote_debug_part2/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/10/01/umdf_remote_debug_part2/","excerpt":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。","text":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。 事前準備以下のパート 1 が完了していること。 Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 1 - ドライバーのビルドとインストール) デバッガーの接続次の手順を実施して、開発環境の PC から ターゲット PC 上のプロセスに対して、デバッガーをアタッチして、デバッグ可能な状態にします。 ターゲット PC 上にインストールした Remote Tools for Visual Studio の Remote Debugger を [管理者として実行] で起動します。初回起動の場合、ファイアウォールの設定が表示されますが、すべて既定の状態で起動します。 [ツール] メニューから [オプション] を選択して、認証の設定を行います。今回は簡略化のため認証なしの設定 (以下) で行います。 設定項目 設定値 TCP&#x2F;IP ポート番号 4026 認証モード 認証なし すべてのユーザーにデバッグを許可する チェックする アイドル タイムの最大値 (秒) 3600 ターゲット PC 上で [ターミナル (管理者)] を起動 (あるいはコマンド プロンプトを管理者として実行) して、次のコマンドを入力します。Visual Studio からデバッガーをアタッチするプロセス ID を確認します。 1tasklist /m wdfsimpleum.dll 開発環境の PC の Visual Studio で [デバッグ] &gt; [プロセスにアタッチ] を選択し (または Ctrl+Alt+P キーを押し)、**[プロセスにアタッチ]** ダイアログ ボックスを開きます。 [接続の種類] を [リモート (Windows - 認証なし)] に設定し、**[検索]** ボタンをクリックします。**[リモート接続]** ダイアログ ボックスを開きます。 手順 2 で設定したターゲット PC が自動で検出されるため [選択] ボタンをクリックして、ダイアログを閉じます。 [プロセスにアタッチ] ダイアログ ボックスに戻り、ターゲット PC 内のプロセス一覧が表示されるため、Ctrl+E キーを押してフィルターのボックスに手順 3 で確認した、デバッグ対象のプロセス ID を入力します。WUDFHost.exe を選択して、**[アタッチする]** をクリックします。 Visual Studio のメニューから [デバッグ] &gt; [ウィンドウ] &gt; [モジュール] の順にクリックして、UMDF ドライバーのシンボルがロードされていることを確認します。 以上でデバッグできる状態になりました。次のステップに進み、実際のデバッグ操作を行います。 ソースコード レベル デバッグの実施現在、ドライバー wdfsimpleum.dll はロードされているだけの状況であり、初期化処理以外は、この段階では特に処理を実行していません。そのためドライバーを呼び出すアプリケーションを実行して、ドライバー コードを実行します。次の手順で、ドライバー コードが実行されたタイミングをデバッガーで捕捉します。 ドライバーに対して ReadFile と DeviceIoControl を呼び出すアプリケーション toast.exe がサンプルには用意されているため、そのアプリケーションを利用します。 以下はドライバーの ReadFile を呼び出しているコード部分の抜粋です。 1234567891011121314151617181920212223//// Read/Write to the toaster device.//printf(&quot;\\nPress &#x27;q&#x27; to exit, any other key to read...\\n&quot;);fflush(stdin);ch = _getche();while(tolower(ch) != &#x27;q&#x27; )&#123; if(!ReadFile(file, buffer, sizeof(buffer), &amp;bytes, NULL)) &#123; printf(&quot;Error in ReadFile: %x&quot;, GetLastError()); break; &#125; printf(&quot;Read Successful\\n&quot;); ch = _getche();&#125;free (deviceInterfaceDetailData);CloseHandle(file);return 0; サンプルをビルドすると以下のパスに toast.exe が生成されるため、このファイルをターゲット PC 側の任意のフォルダー (C:\\temp など) へコピーします。 12345678umdf2└─exe ├─enum ├─notify └─toast └─x64 (or arm64) └─Debug (or Release) └─ toast.exe ターゲット PC 上の管理者権限で実行されているコマンドプロンプトにて toast.exe を実行します。次のような出力が得られればデバイスのオープンができています。 1234567891011121314c:\\temp&gt;toast.exeInstance ID : ROOT\\UNKNOWN\\0000Description : Sample UMDF Toaster Driver - simpleFriendlyName:List of Toaster Device Interfaces---------------------------------1) \\\\?\\root#unknown#0000#&#123;781ef630-72b2-11d2-b852-00c04fad5171&#125;Opening the last interface:\\\\?\\root#unknown#0000#&#123;781ef630-72b2-11d2-b852-00c04fad5171&#125;Press &#x27;q&#x27; to exit, any other key to read... [!NOTE]toast.exe の実行時 VCRUNTRIME140.dll が見つからないといったエラーが出る場合は、プロジェクトのプロパティでランタイム ライブラリの設定を /MT あるいは /MTd にしてビルドすることで回避できます。関連ドキュメント: &#x2F;MD、&#x2F;MT、&#x2F;LD (ランタイム ライブラリを使用) 開発環境の Visual Studio で Func\\Simple\\Source Files\\toast.c を開き、ToasterEvtIoRead 関数の先頭にブレークポイントをセットします。 ターゲット PC の toast.exe を実行したコンソール画面に戻り、’q’ キー以外の任意のキーを押下します。すると、開発環境の Visual Studio 側で ToasterEvtIoRead 関数でブレークインして、実行が停止します。そして、デバッグしたいコードまで F10 キーなどを押下することでステップ実行することができます。 まとめ以上、パート 2 ではリモートデバッガーを接続して、任意のタイミングで実行されるコードのデバッグを行えることまでを確認しました。 次回の記事では、任意のタイミングではなく UMDF ドライバーの DriverEntry や EvtDriverDeviceAdd ルーチンといった初期化処理におけるリモート デバッグについて説明します。 変更履歴2025/10/01 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/tags/Debug/"},{"name":"UMDF","slug":"UMDF","permalink":"https://jpwdkblog.github.io/blog/tags/UMDF/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://jpwdkblog.github.io/blog/tags/Visual-Studio/"}],"keywords":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}]},{"title":"Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 1 - ドライバーのビルドとインストール)","slug":"umdf_remote_debug_part1","date":"2025-09-29T15:00:00.000Z","updated":"2025-10-01T07:16:53.446Z","comments":true,"path":"2025/09/30/umdf_remote_debug_part1/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/09/30/umdf_remote_debug_part1/","excerpt":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。","text":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。 事前準備 ドライバーをビルド・デバッグを行う開発環境の PC とドライバーを実行しテストを行うターゲット PC をそれぞれ 1 台ずつ計 2 台の PC あるいは仮想マシンを用意します。 開発環境には Visual Studio、Windows Driver Kit (WDK) をインストールし、Windows Driver Kit サンプルを事前にダウンロードしておきます。WDK のインストールと、サンプルのダウンロードは次のリンクをご参照ください。 Download the Windows Driver Kit (WDK) GitHub - Windows-driver-samples ターゲット PC に Remote Tools for Visual Studio をインストールします。 Download and Install the remote tools ターゲット PC でテスト署名を有効化します。必要に応じて事前にセキュア ブートを BIOS で無効化します。テスト署名の有効化は、ドキュメント “テスト署名されたドライバーの読み込みを有効にする“ にあるように、管理者権限で起動したコマンド プロンプトで bcdedit.exe を次のように呼び出します。1Bcdedit.exe -set TESTSIGNING ON User Mode Driver について事前準備が完了したらサンプル ドライバーのビルドを行います。この記事では User Mode Driver を対象としておりますが、User Mode Driver と言っても様々な種類があります。例えば次のような種類のドライバーがあります。 GPS &#x2F; GNSS (Global Navigation Satellite System GNSS) driver GPIO peripheral device driver Indirect display driver UMDF NetAdapterCx client driver POS barcode scanner driver Printer driver ※ WIA driver ※ ※ Printer および WIA ドライバーは一般的な User Mode Driver Framework (UMDF) のドライバーとは異なるため、この記事のシリーズで紹介している内容の一部は適用されません。 サンプル ドライバーのビルドこの記事では Generic なサンプルとして提供されている Toaster サンプルを使用します。Toaster サンプルは KMDF 版と UMDF 版の2種類がありますが UMDF 版は Windows-driver-samples&#x2F;general&#x2F;toaster&#x2F;umdf2 にあります。 開発環境 PC の Visual Studio で Windows-driver-samples\\general\\toaster\\umdf2\\umdf2toaster.sln を開きます [Solution Explorer] を見ると、そのソリューション内には Exe, Filter, Func, Package というプロジェクトがありますが、ひとまず Solution 部分をクリックします。 続いて、ビルド対象を選びます。 [ビルド] メニューから [ソリューションのリビルド] を選びビルドします。 ビルドが正常に終わると、その結果として x64 Debug の場合、次のような出力ファイルが得られます。12345678910umdf2└─x64 └─Debug ├─package.cer └─package ├─filterum.dll ├─filterum.inf ├─wdfsimpleum.dll ├─wdfsimpleum.inf └─wudf.cat ドライバーのインストールドライバーのインストールにはいくつか方法がありますが、今回はドライバー パッケージを手動でターゲット PC にコピーして、デバイス マネージャーを使ってインストールします。 前の手順の 5 の Debug フォルダーをターゲット PC の任意のフォルダーにコピーします。 ターゲット PC 上でコピー先フォルダー内にある package.cer を右クリックして [証明書のインストール] をクリックします。 証明書のインポート ウィザードで次の設定で選び、完了 をクリックして証明書をインポートします。 設定項目 設定値 保存場所 ローカル コンピューター 証明書をすべて次のストアに配置する チェックする 証明書ストア 信頼されたルート証明機関 物理ストアを表示する チェックしない スタート メニューを右クリックしてデバイス マネージャーを起動します。 [操作] メニューをクリックして、**[レガシ ハードウェアの追加]** をクリックします。 [ハードウェアの追加] ウィザードで、次の設定を行い、ドライバーとデバイスのインストールを行います。6-1. インストール方法の選択で [一覧から選択したハードウェアをインストールする (詳細)] を選び次へ。6-2. [共通ハードウェアの種類] で [すべてのデバイスを表示] を選び次へ。6-3. [ディスクを使用] をクリックして、ドライバー パッケージをコピーしたフォルダーに移動して wdfsimpleum.inf を選び [開く] をクリックします。6-4. Sample UMDF Toaster Driver - simple を選び [次へ] をクリックし、残りのウィザードを進め完了します。 デバイス マネージャーに次のように表示されインストールが完了していることが分かります。 また、スタート メニューから管理者権限でターミナルを起動し、次のコマンドを入力すると UMDF ドライバーがどのプロセスにロードされているのかを確認できます。 12345PS C:\\&gt; tasklist /m wdfsimpleum.dllImage Name PID Modules========================= ======== ============================================WUDFHost.exe 12412 wdfsimpleum.dll ドライバーのインストール ログを確認する場合は C:\\Windows\\INF\\setupapi.dev.log を参照します。ログの見方などについては SetupAPI テキスト ログ をご参照下さい。以下は実際に Toaster UMDF ドライバーをインストールした時のログの抜粋です。 &gt;&gt;&gt; [Device Install (DiInstallDevice) - ROOT\\UNKNOWN\\0000] &gt;&gt;&gt; Section start 2025/09/30 17:19:51.937 cmd: &quot;C:\\WINDOWS\\system32\\mmc.exe&quot; C:\\WINDOWS\\system32\\devmgmt.msc ndv: Flags: 0x00000002 dvi: Class GUID of device changed to: &#123;b85b7c50-6a01-11d2-b841-00c04fad5171&#125;. sto: &#123;Setup Import Driver Package: c:\\temp\\debug\\package\\wdfsimpleum.inf&#125; 17:19:51.939 inf: Provider: TODO-Set-Provider inf: Class GUID: &#123;B85B7C50-6A01-11d2-B841-00C04FAD5171&#125; inf: Driver Version: 09/30/2025,16.8.45.553 inf: Catalog File: wudf.cat sto: &#123;Copy Driver Package: c:\\temp\\debug\\package\\wdfsimpleum.inf&#125; 17:19:51.943 sto: Driver Package = c:\\temp\\debug\\package\\wdfsimpleum.inf sto: Flags = 0x00000007 sto: Destination = C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125; sto: Copying driver package files to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;&#39;. flq: &#123;FILE_QUEUE_COMMIT&#125; 17:19:51.945 flq: Copying &#39;c:\\temp\\debug\\package\\wdfsimpleum.dll&#39; to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wdfsimpleum.dll&#39;. flq: Copying &#39;c:\\temp\\debug\\package\\wdfsimpleum.inf&#39; to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wdfsimpleum.inf&#39;. flq: Copying &#39;c:\\temp\\debug\\package\\wudf.cat&#39; to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wudf.cat&#39;. flq: &#123;FILE_QUEUE_COMMIT - exit(0x00000000)&#125; 17:19:51.953 sto: &#123;Copy Driver Package: exit(0x00000000)&#125; 17:19:51.953 ump: Import flags: 0x00000000 pol: &#123;Driver package policy check&#125; 17:19:52.002 pol: &#123;Driver package policy check - exit(0x00000000)&#125; 17:19:52.002 sto: &#123;Stage Driver Package: C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wdfsimpleum.inf&#125; 17:19:52.002 inf: Provider = TODO-Set-Provider inf: Class GUID = &#123;b85b7c50-6a01-11d2-b841-00c04fad5171&#125; inf: Driver Version = 09/30/2025,16.8.45.553 inf: Catalog File = wudf.cat inf: Version Flags = 0x00000013 (以下、省略) まとめ以上でドライバーのインストールまで完了です。今回ドライバーのインストールは、デバイス マネージャーから手動でインスールしましたが、実際のドライバーはデバイスの接続に応じたプラグアンドプレイによるインストールになることが想定されます。なお、今回のインストールでは ROOT\\Unknown\\0000 というデバイス インスタンスを作成して、ドライバーを割り当てているため、物理的なデバイスは存在していません。USB などのプラグアンドプレイのシナリオでは、バス ドライバーが USB\\VID_xxxx&amp;PID_yyyy\\* のようなデバイス インスタンスを生成し、ドライバーがインストールされます。 次回の記事では、実際にリモートでデバッガーを接続してアプリケーションからドライバーを呼び出した時の様子を開発環境上の PC で動作する Visual Studio でデバッグする作業を行います。 変更履歴2025/09/30 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。 ※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/tags/Debug/"},{"name":"UMDF","slug":"UMDF","permalink":"https://jpwdkblog.github.io/blog/tags/UMDF/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://jpwdkblog.github.io/blog/tags/Visual-Studio/"}],"keywords":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}]},{"title":"HLK のテストが失敗した場合のトラブルシューティング手順","slug":"howto-troubleshoot-hlk-test-fail","date":"2025-07-09T15:00:00.000Z","updated":"2025-10-01T07:16:53.226Z","comments":true,"path":"2025/07/10/howto-troubleshoot-hlk-test-fail/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/07/10/howto-troubleshoot-hlk-test-fail/","excerpt":"この記事では、Hardware Lab Kit (HLK) のテストで FAIL が発生した時の一般的なトラブルシューティング方法をご案内いたします。","text":"この記事では、Hardware Lab Kit (HLK) のテストで FAIL が発生した時の一般的なトラブルシューティング方法をご案内いたします。 1. HLK で実施すべきテスト項目であったかどうかを確認するまず、前提として実施されたテスト項目が認定を受けるうえで必須のテスト項目であったかどうかをチェックします。HLK のテストは、Windows Hardware Compatibility Program Specifications and Policies で定義されている要件に沿ったドライバーあるいはハードウェアであるかどうかをチェックする目的があります。つまり、対象のドライバーおよびデバイスに対するポリシー要件を定義されていない内容に対するテストは、そもそも実施する必要がありません。実施すべきテストのみが正しく選択されているかどうかは、”プレイリスト” が適用されているかどうかによって変わります。 この “プレイリスト” については、次のドキュメントに適用方法が記載されていますので、こちらをご覧ください。手順 6:テストの選択と実行 - プレイリスト “プレイリスト” ファイルは、次のドキュメントからダウンロードできます。Windows ハードウェア互換性プログラム - プレイリスト 2. HLK FiltersHLK では、テスト ツールそのものの問題や OS 側の問題、要件定義の問題など、お客様デバイスやドライバー以外が原因でテストが Fail となる場合があります。このような場合、その Fail についてはテスト結果を免除するためのフィルターがあります。フィルターのインストール手順とダウンロードは こちら からご確認いただけます。フィルターは機械的に毎日更新処理が実行されており、アップデートがある場合はフィルター ファイルも更新されます。そのため、テストを実施する場合は、まずフィルターのダウンロードと更新作業を実施いただくことをお勧めします。 その他フィルターの有無を DTM Filtes にて確認します。HLK Filters には、自動で適用されるもの以外にマニュアルで適用されるものもあります (通称、Manual Errata)。これは、マイクロソフトのサポート エンジニアからの指示のもとで適用されるフィルターとなります。基本的には、弊社までお問い合わせいただくことが前提となります。前述のサイトに関連しそうな内容や類似のものが見つかった場合は、お気兼ねなく 弊社サポート までお問い合わせください。お問い合わせいただく際の製品カテゴリは次の通りです。 3. エラー メッセージの確認エラーログは通常、ログファイル（.wtl）に記録されており、[Result] タブでテスト結果をダブルクリックすることで開くことができます。どのテストで失敗しているのかを確認後、対応するテスト ドキュメントを確認します。テスト ドキュメントには、事前に設定すべき内容(Prerequisites) や、事前に設定すべきパラメータ (Parameters) などが記載されています。テストによっては、手動操作が求められているものもあるため、操作が不足していないかなどもご確認ください。 例：Audio Codec - USB Audio Logo Test (Manual) - Certification - Desktop 4. トラブル シューティング作業失敗したテストは、そのテスト ツールだけをエクスポートして、HLK コントローラなしでスタンドアロンで個別実行することが可能です。この操作によって、デバッグ作業やログ採取など必要なアクションを行いやすくできる場合があります。次のドキュメントで失敗したテストジョブのエクスポート手順および実行手順が記載されていますので、ご確認ください。失敗した HLK ジョブのエクスポート また、すべてのドライバーは DF - InfVerif INF Verification と呼ばれるテストが実行されます。このテストは、ドライバーをインストールするための INF ファイルの記述などの検証を行うテストとなります。基本的に OS のバージョンが新しいものになるにつれて、INF の記述に関する要件が増え、より厳格になっている傾向があります。お客様のドライバーが要件に沿っているかどうかをチェックするためには、Windows Hardware Compatibility Program Specifications and Policies をご確認いただく必要がありますが、最新の Windows Driver Kit に含まれている InfVerif ツールを用いてツールでチェックすることもできます。要件に沿っているかどうかは &#x2F;h オプションを指定してツールを実行します。 なお、HLK とは直接関係ありませんが、HLK のテストを行わずにドライバーへの署名だけを Hardware DevCenter に依頼する場合も、この InfVerif ツールの検証だけは行われます。そのため、ドライバーを作成した場合は、必ず InfVerif &#x2F;h での検証を行っていただくことをお勧めいたします。 関連情報Windows HLK 環境のトラブルシューティングWindows HLK テストのエラーのトラブルシューティングINF の検証エラーと警告 変更履歴2025&#x2F;07&#x2F;10 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"hlk","slug":"hlk","permalink":"https://jpwdkblog.github.io/blog/categories/hlk/"}],"tags":[{"name":"test","slug":"test","permalink":"https://jpwdkblog.github.io/blog/tags/test/"}],"keywords":[{"name":"hlk","slug":"hlk","permalink":"https://jpwdkblog.github.io/blog/categories/hlk/"}]},{"title":"Windows 11 24H2 で印刷を行うとメモリリークが発生することがある","slug":"printing-causes-memory-leak","date":"2025-07-09T08:00:00.000Z","updated":"2025-10-01T07:16:53.376Z","comments":true,"path":"2025/07/09/printing-causes-memory-leak/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/07/09/printing-causes-memory-leak/","excerpt":"この記事では、Windows 11 24H2 および Windows Server 2025 上での印刷処理において発生するメモリリークについて説明します。","text":"この記事では、Windows 11 24H2 および Windows Server 2025 上での印刷処理において発生するメモリリークについて説明します。 概要Windows Version 24H2 (OS Build 26100) において、v3 プリンター ドライバーを使ってドキュメントを印刷すると、スプーラー サービス (spoolsv.exe) でメモリリークが発生することを確認しております。 この現象は、v3 プリンター ドライバーの DrvEnableSurface コールバック関数以外のコールバック関数で EngCreateBitmap 関数 を呼び出している場合に発生します。例えば、DrvBitBlt や DrvStretchBlt などのようなビット ブロック転送機能を実装するドライバーのコールバック関数で EngCreateBitmap &#x2F; EngDeleteSurface 関数 の呼び出しで発生します。印刷するドキュメントの内容によって、ドライバーで実行されるコードパスが変わるため、事象の発生は 100 %ではありません。 現象印刷を繰り返すと、spoolsv.exe のメモリ使用量 (タスク マネージャーのワーキング セットやコミット サイズ) の値が徐々に増加します。 また、実際にメモリの解放が失敗した時には、EngDeleteSurface 関数の呼び出しが失敗 (FALSE を返す) ことが確認されています。ドライバー側の処理で、EngDeleteSurface 関数の戻り値を確認していただくことでも、事象の発生有無を確認することができます。 回避方法現状、この問題を確実に回避する方法はありませんが、プリンタードライバーの分離機能を有効化することで、常時実行されているスプーラー サービスで発生するメモリリークの問題を別のプロセス (PrintIsolationHost.exe) に分離することができます。この PrintIsolationHost.exe は常駐で実行されるものではなく、一定時間使用されなくなるとプログラムが自動で終了します。確保されていたメモリはプログラム (.exe) が終了すると、強制的に解放されるため、結果的にメモリリークしていたメモリも解放さることになります。プリンタードライバーの分離機能を有効化するためには、次の手順を実行します。 [印刷の管理] を起動します。 左側のペインで [プリント サーバー] - [&lt;PC 名&gt; (ローカル)] - [ドライバー] の順に展開します。対象のプリンタードライバーを右クリックして [ドライバーの分離の設定] - [分離] の順にクリックして機能を有効化します。 状況本問題は、Windows における GDI の問題であると認識しており、現在修正作業行っております。現時点で、Windows 11 24H2 に対する修正は 2025 年 9 月の提供を目標に作業中です。Windows Server OS については、クライアント OS の提供後、約 4 カ月後となるため 2026 年 1 月あるいは 2 月に提供となる見込みです。なお、修正プログラムの提供は、他の修正プログラムの影響なども受けるため、状況によって予定は変更となる場合がございます。今後の状況については、アップデートがあり次第こちらで更新します。 2025 年 7 月 28 日更新本問題の修正が含まれる累積更新プログラム全体のテスト パスが開始中しています。現段階では作業に遅延は確認されていません。次回は 8 月の第 1 週目を目途に更新いたします。 2025 年 8 月 12 日更新予定通りテストは大きな問題もなく完了しました。現段階では作業に遅延は確認されていません。次回は 8 月 25 日の週に更新を予定しています。 2025 年 8 月 29 日更新8 月の オプションのセキュリティ以外のプレビュー リリースのサインオフの作業に若干の遅れが生じていましたが、近日中にリリース予定です。次回は前述のプレビュー リリースが公開になりましたら更新いたします。関連情報：更新プログラムのリリース サイクル 2025 年 9 月 02 日更新8 月の オプションのセキュリティ以外のプレビュー リリースが以下にて公開されました。本問題の修正コードが有効化される次回オプションのセキュリティ以外のプレビュー リリースは、9 月の第 4 週の提供予定となっております。現時点では 9 月 24 日にスケジュールされていますが状況によって変わる場合がございます。9 月の第 3 週に改めて更新いたします。関連情報：2025 年 8 月 29 日 — KB5064081 (OS ビルド 26100.5074) プレビュー 2025 年 9 月 30 日更新9 月の オプションのセキュリティ以外のプレビュー リリースが以下にて公開されました。KB5065789 をインストールすることで、本メモリリークの問題に対する修正プログラムが適用されます。関連情報：2025 年 9 月 29 日 — KB5065789 (OS ビルド 26100.6725) プレビュー関連情報：Microsoft Update Catalog 変更履歴2025/07/10 created by riwaida2025/07/28 updated by riwaida2025/08/12 updated by riwaida2025/08/29 updated by riwaida2025/09/02 updated by riwaida2025/09/30 updated by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"print","slug":"print","permalink":"https://jpwdkblog.github.io/blog/tags/print/"},{"name":"Windows 11 24H2","slug":"Windows-11-24H2","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11-24H2/"},{"name":"Windows Server 2025","slug":"Windows-Server-2025","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-Server-2025/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Print Support App (PSA) にて用紙の設定が既定の値にならない","slug":"psa-default-value-issue","date":"2024-08-22T15:00:00.000Z","updated":"2025-10-01T07:16:53.399Z","comments":true,"path":"2024/08/23/psa-default-value-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2024/08/23/psa-default-value-issue/","excerpt":"この記事では Print Support App で発生する問題について説明します。","text":"この記事では Print Support App で発生する問題について説明します。 概要PSA の PrintSupportExtensionSession.PrintDeviceCapabilitiesChanged イベント ハンドラーで PrintDeviceCapabilities に追加の PageMediaType オプションを追加すると、既定のオプションが選ばれない現象が発生します。 現象例えば PageMediaType Feature で ContosoMediaType というのを追加し、次のような PrintTicket を構成した場合 default=&quot;true&quot; が指定されている AutoSelect がオプションとして既定の設定となることが期待されます。 1234567&lt;!-- media-type-supported --&gt;&lt;psk:PageMediaType psf2:psftype=&quot;Feature&quot;&gt; &lt;psk:AutoSelect psf2:psftype=&quot;Option&quot; psf2:default=&quot;true&quot;/&gt; &lt;psk:PhotographicGlossy psf2:psftype=&quot;Option&quot; psf2:default=&quot;false&quot;/&gt; &lt;psk:Photographic psf2:psftype=&quot;Option&quot; psf2:default=&quot;false&quot;/&gt; &lt;contoso:ContosoMediaType psf2:psftype=&quot;Option&quot; psf2:default=&quot;false&quot;/&gt;&lt;/psk:PageMediaType&gt; しかし、実際には別のオプションが既定の PrintTicket として構成される現象が発生します。本現象は PSA の印刷設定画面の最初の表示時に発生し、一度、設定が保存されると問題は発生いたしません。 回避方法本現象を回避するためには、PSA の PrintSupportExtensionSession.PrintDeviceCapabilitiesChanged イベント ハンドラーにて、既定のオプションとなるオプションを PSA 自身で保存し、ユーザー既定の PrintTicket を印刷設定ダイアログを表示するタイミングで、保存した値をリストアすることで回避可能出来ます。 １．まず、PSA の BackgroundTask の LocalStorageUtil クラスに次のようなコードを追加します。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 // 既に既定のオプションを PrintTicket へ設定したかどうかを確認するためのメソッド public static bool IsAlreadyLoadedDefaultValue() &#123; try &#123; return (bool)ApplicationData.Current.LocalSettings.Values[&quot;IsLoadedDefaultValue&quot;]; &#125; catch (NullReferenceException e) &#123; return false; &#125; &#125; // 既定のオプションを PrintTicket へ適用したことを示すためのメソッド public static void LoadedDefaultValue(bool _bLoaded) &#123; ApplicationData.Current.LocalSettings.Values[&quot;IsLoadedDefaultValue&quot;] = _bLoaded; &#125; // 指定 Feature のデフォルト オプションの値を保存します public static void SetPdcDefaultValue(string _Feature, string _DefaultValue) &#123; System.Diagnostics.Debug.WriteLine(&quot;SetPdcDefaultValue: Feature=&quot; + _Feature + &quot;, Default=&quot; + _DefaultValue); ApplicationData.Current.LocalSettings.Values[_Feature] = _DefaultValue; &#125; // 指定 Feature のデフォルト オプションの値を返します public static string GetPdcDefaultValue(string _Feature) &#123; try &#123; return (string)ApplicationData.Current.LocalSettings.Values[_Feature]; &#125; catch (NullReferenceException e) &#123; System.Diagnostics.Debug.WriteLine(e.Message); return null; &#125; &#125;``` ２．`PrintSupportExtensionSession.PrintDeviceCapabilitiesChanged` イベント ハンドラーに、手順１で追加した `SaveDefaultValues()` を呼び出して、Print Device Capabilities に設定されている既定値を保存します。```C# private void OnSessionPrintDeviceCapabilitiesChanged(PrintSupportExtensionSession sender, PrintSupportPrintDeviceCapabilitiesChangedEventArgs args) &#123; var pdc = args.GetCurrentPrintDeviceCapabilities(); // Add the custom namesapce uri to the XML document. pdc.DocumentElement.SetAttribute(&quot;xmlns:contoso&quot;, &quot;http://schemas.contoso.com/keywords&quot;); // Add the custom media type. AddCustomMediaType(ref pdc, &quot;http://schemas.contoso.com/keywords&quot;, &quot;contoso:ContosoMediaType&quot;); // PDC のデフォルト値を保存するメソッドを呼び出します SaveDefaultValues(ref pdc); args.UpdatePrintDeviceCapabilities(pdc); args.SetPrintDeviceCapabilitiesUpdatePolicy( PrintSupportPrintDeviceCapabilitiesUpdatePolicy.CreatePeriodicRefresh(System.TimeSpan.FromMinutes(1))); args.GetDeferral().Complete(); &#125; ３．手順１と２で LocalStorageUtil に保存したオプションの既定値をコンボボックスの初期化処理などで利用し、コンボボックス アイテムの初期に設定します。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private ComboBox CreatePrintTicketFeatureComboBox(PrintTicketFeature feature, bool useDefaultEventHandler = true)&#123; if (feature == null) &#123; return null; &#125; var comboBox = new ComboBox &#123; // Header is displayed in the UI, ontop of the ComboBox. Header = feature.DisplayName &#125;; // Construct a new List since IReadOnlyList does not support the &#x27;IndexOf&#x27; method. var options = new ObservableCollection&lt;PrintTicketOption&gt;(feature.Options); // Provide the combo box with a list of options to select from. comboBox.ItemsSource = options; // Set the selected option to the option set in the print ticket. PrintTicketOption selectedOption; // PDC の既定値を LocalStorageUtil から1回だけ読み込む string defaultOption = LocalStorageUtil.GetPdcDefaultValue(feature.Name); if (!LocalStorageUtil.IsAlreadyLoadedDefaultValue() &amp;&amp; defaultOption != null) &#123; selectedOption = options[0]; foreach (var option in options) &#123; if (option.Name == defaultOption) &#123; // デフォルト値 selectedOption = option; break; &#125; &#125; &#125; else &#123; var featureOption = feature.GetSelectedOption(); try &#123; selectedOption = options.Single((option) =&gt; ( option.Name == featureOption.Name &amp;&amp; option.XmlNamespace == featureOption.XmlNamespace)); &#125; // Catch exceptions, because there can be multiple features with the &quot;None&quot; feature name. // We need to handle those features seperately. catch (System.SystemException exception) &#123; var nameAttribute = featureOption.XmlNode.Attributes.GetNamedItem(&quot;name&quot;); var attribute = featureOption.XmlNode.OwnerDocument.CreateAttribute(&quot;name&quot;); selectedOption = options.Single((option) =&gt; ( option.DisplayName == featureOption.DisplayName &amp;&amp; option.Name == featureOption.Name &amp;&amp; option.XmlNamespace == featureOption.XmlNamespace)); &#125; &#125; comboBox.SelectedIndex = options.IndexOf(selectedOption); // LocalStorageUtil からの読み込みが完了したことをセットします LocalStorageUtil.LoadedDefaultValue(true); 関連ドキュメントPrintSupportExtensionSession.PrintDeviceCapabilitiesChanged イベント 変更履歴2024/08/07 created by riwaida2024/08/24 modified by riwaida : 回避方法の追加2025/07/10 modified by riwaida : 変更履歴の記載","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"printer","slug":"printer","permalink":"https://jpwdkblog.github.io/blog/tags/printer/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Print Support App (PSA) の初回起動時、[設定] ウィンドウの背面に表示されてしまう","slug":"psa-z-order-issue","date":"2024-08-14T15:00:00.000Z","updated":"2025-10-01T07:16:53.416Z","comments":true,"path":"2024/08/15/psa-z-order-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2024/08/15/psa-z-order-issue/","excerpt":"この記事では Print Support App で発生する問題について説明します。","text":"この記事では Print Support App で発生する問題について説明します。 概要Print Support App (PSA) がインストールされた直後などにおいて、[設定] から起動時ウィンドウが設定画面の背後に隠れてしまう事象が発生します。PSA が起動する際、つぎのダイアログが表示されるケースで事象が発生します。 現象問題の事象が発生する手順は次の通りです。 スタート メニューから [設定] をクリックします。 [Bluetooth とデバイス] - [プリンターとスキャナー] の順にクリックします。 表示されたプリンターの一覧から PSA を起動するプリンターをクリックします。 [印刷設定] をクリックします。 次の青く囲った部分のように、PSA のウィンドウが設定画面の背後に隠れてしまうことがあります。 状況この現象については開発部門にて今後の対応を (次期メジャー OS アップデートでの対応について) 検討中となります。 変更履歴2024/08/15 created by riwaida2025/07/10 modified by riwaida : 状況の更新","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"printer","slug":"printer","permalink":"https://jpwdkblog.github.io/blog/tags/printer/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"CPrintDialog を利用したアプリケーションから印刷できない","slug":"printer-CPrintDialog-issue","date":"2023-06-04T15:00:00.000Z","updated":"2025-10-01T07:16:53.300Z","comments":true,"path":"2023/06/05/printer-CPrintDialog-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2023/06/05/printer-CPrintDialog-issue/","excerpt":"この記事は、CPrintDialog を利用したアプリケーションから印刷した際に発生する問題について説明します。","text":"この記事は、CPrintDialog を利用したアプリケーションから印刷した際に発生する問題について説明します。 現象MFC の CPringDialog クラスを利用して [印刷] ダイアログから印刷を行った場合、正常に印刷が行われない場合があります。この現象は CPrintDialog::CPrintDialog() の第一引数 bPrintSetupOnly に TRUE、第二引数 dwFlags に PD_USEDEVMODECOPIES を指定している、または第二引数に何も設定していない場合に発生します。(第二引数 dwFlags に何も設定しない場合は、既定で PD_USEDEVMODECOPIES が設定されます。) なお、この現象が発生するとき、プリンター ドライバー側の視点では DrvStartDoc 関数が呼ばれません。 原因CPrintDialog::CPrintDialog() の第一引数 bPrintSetupOnly に TRUE、第二引数 dwFlags に PD_USEDEVMODECOPIES が指定された状況では、PrintDialog::m_pd構造体の nCopies メンバーが既定で 0 となります。この値は、印刷する部数を示しており、最終的に DEVMODE 構造体の dmCopies メンバーに設定されて GDI およびプリンタードライバーで利用されます。GDI は DEVMODE.dmCopies が 0 の場合、印刷する部数は無いものと判断して印刷を行いません。その際、GDI はプリンター ドライバーの DrvStartDoc 関数を呼び出しません。 回避方法CPrintDialog::CPrintDialog() の実行後に CPrintDialog::m_pd構造体の nCopies メンバーに 1 を設定します。 以下は回避方法としてのサンプルコード例となります。 CPrintDialog::CPrintDialog(TRUE) で dlg オブジェクトを構築した後に、m_pd構造体の nCopies に 1 を設定して、StartDoc 関数を実行します。 1234567891011121314151617181920212223242526272829303132HDC printHDC;CString strMsg;CPrintDialog dlg(TRUE);dlg.m_pd.nCopies = 1; if (dlg.DoModal() == IDOK)&#123; // DEVMODEの取得 DEVMODE* devmode = dlg.GetDevMode(); //印刷用HDCの取得 printHDC = CreateDC(NULL, dlg.GetDeviceName(), NULL, devmode); if (NULL == printHDC) &#123; strMsg.Format(_T(&quot;CreateDC is NULL&quot;)); MessageBox(strMsg); return; &#125; CDC PrinterDC; PrinterDC.Attach(printHDC); CString docname; docname.Format(_T(&quot;PrintTest&quot;)); DOCINFO docinfo = &#123; 0 &#125;; //DOCINFOを用意 docinfo.cbSize = sizeof(docinfo); docinfo.lpszDocName = docname; PrinterDC.StartDoc(&amp;docinfo); 参考情報CPrintDialog クラスDEVMODEA 構造体 (wingdi.h)PRINTDLGA structure (commdlg.h) 変更履歴2023&#x2F;06&#x2F;05 created by mitsuchi ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"CPrintDialog","slug":"CPrintDialog","permalink":"https://jpwdkblog.github.io/blog/tags/CPrintDialog/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"プリンタ― ドライバ―のアップデートを行った際に DEVMODE 情報が更新されない","slug":"printer-devmode-issue","date":"2022-09-19T15:00:00.000Z","updated":"2025-10-01T07:16:53.337Z","comments":true,"path":"2022/09/20/printer-devmode-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2022/09/20/printer-devmode-issue/","excerpt":"この記事は、プリンタードライバーのアップデートを行った際に発生する問題について説明します。","text":"この記事は、プリンタードライバーのアップデートを行った際に発生する問題について説明します。 前提となるシナリオプリンタードライバーのアップデート時にプライベート部分の DEVMODE サイズや構造体をプリンタードライバーが更新している場合になります。 発生する問題プリンタードライバーのアップデート時、更新されるドライバーでは、プライベート部分の DEVMODE サイズや構造体を更新している場合があります。このようなシナリオでは、プリンタードライバーが依頼した新しいバージョンの DEVMODE の形式に合わせて、各種 DEVMODE の値を OS が レジストリへ保存・更新します。しかし、ドライバーの更新タイミングにおいて、OS がレジストリへの書き込み処理を行わない問題があるため、システムの再起動等を行うと、印刷設定が保存されなかったり、プリンタードライバーが予期せぬ挙動を示したりする場合があります。 回避方法以下の OS のバージョンでは修正されております。 ・Windows 11・Windows 10 21H2 (2022 年 6 月 28 日 — KB5014666 (OS ビルド 19042.1806、19043.1806、19044.1806) プレビュー) 以降の更新プログラムが適用されている環境それ以外の OS バージョンでは、明示的に SetPrinter を呼び出して DEVMODE が格納されているレジストリの更新を行います。なお、この際、スプーラーサービスが保持している DEVMODEと同じ値で SetPrinter を実行した場合、レジストリの更新が行われないため、次のように確実にてレジストリが更新されるよう、一時的に DEVMODE の値を変更して SetPrinter を 実行します。回避方法としては、プリンタ―ドライバ―のアップデート後に、GetPrinter を1回、SetPrinter を2回呼び出します。１．まず、GetPrinter を呼び出して、現在の DEVMODE を取得します。２．続いて、1で取得した現在の DEVMODE から、値を変更（例えば、dmOrientation の値など）した DEVMODE を SetPrinter でセットします。この時、レジストリが更新されます。３．最後に 1 で取得した現在の DEVMODE をそのまま、SetPrinter でセットし、値を元に戻し、かつレジストリも再度更新します。Modify printer settings by using the SetPrinter function のサンプル コードをベースとした回避方法の例となります。上記 「１．まず、GetPrinter を呼び出して、現在の DEVMODE を取得します。」については、dmOrientation の値を変更するための DEVMODE と 「３．最後に 1 で取得した現在の DEVMODE をそのまま、SetPrinter でセットし、値を元に戻し、かつレジストリも再度更新します。」で 元に戻す DEVMODE を取得するために 2 回 GetPrinter を呼び出しています。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// MySetPrinter// Demonstrates how to use the SetPrinter API. This particular function changes the orientation// for the printer specified in pPrinterName to the orientation specified in dmOrientation.// Valid values for dmOrientation are:// DMORIENT_PORTRAIT (1) or DMORIENT_LANDSCAPE (2)BOOL MySetPrinter(LPTSTR pPrinterName, short dmOrientation)&#123; HANDLE hPrinter = NULL; DWORD dwNeeded = 0; PRINTER_INFO_2 *pi2 = NULL; PRINTER_INFO_2 *pi2_org = NULL; DEVMODE *pDevMode = NULL; PRINTER_DEFAULTS pd; BOOL bFlag; LONG lFlag; // Open printer handle (on Windows NT, you need full-access because you // will eventually use SetPrinter)... ZeroMemory(&amp;pd, sizeof(pd)); pd.DesiredAccess = PRINTER_ALL_ACCESS; bFlag = OpenPrinter(pPrinterName, &amp;hPrinter, &amp;pd); if (!bFlag || (hPrinter == NULL)) return FALSE; // The first GetPrinter tells you how big the buffer should be in // order to hold all of PRINTER_INFO_2. Note that this should fail with // ERROR_INSUFFICIENT_BUFFER. If GetPrinter fails for any other reason // or dwNeeded isn&#x27;t set for some reason, then there is a problem... SetLastError(0); bFlag = GetPrinter(hPrinter, 2, 0, 0, &amp;dwNeeded); if ((!bFlag) &amp;&amp; (GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (dwNeeded == 0)) &#123; ClosePrinter(hPrinter); return FALSE; &#125; // Allocate enough space for PRINTER_INFO_2... pi2 = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded); if (pi2 == NULL) &#123; ClosePrinter(hPrinter); return FALSE; &#125; //１．まず、GetPrinter を呼び出して、現在の DEVMODE を取得します。 //３．で DEVMODE の値を戻すために呼び出します。 // The second GetPrinter fills in all the current settings, so all you // need to do is modify what you&#x27;re interested in... bFlag = GetPrinter(hPrinter, 2, (LPBYTE)pi2, dwNeeded, &amp;dwNeeded); if (!bFlag) &#123; GlobalFree(pi2); ClosePrinter(hPrinter); return FALSE; &#125; pi2_org = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded); if (pi2_org == NULL) &#123; GlobalFree(pi2); ClosePrinter(hPrinter); return FALSE; &#125; //１．GetPrinter を呼び出して、現在の DEVMODE を取得します。 //２．で dmOrientation の値を変更するために呼び出します。 bFlag = GetPrinter(hPrinter, 2, (LPBYTE)pi2_org, dwNeeded, &amp;dwNeeded); if (!bFlag) &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; // Driver is reporting that it doesn&#x27;t support this change... if (!(pi2-&gt;pDevMode-&gt;dmFields &amp; DM_ORIENTATION)) &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; // Specify exactly what we are attempting to change... pi2-&gt;pDevMode-&gt;dmFields = DM_ORIENTATION; pi2-&gt;pDevMode-&gt;dmOrientation = dmOrientation; // Do not attempt to set security descriptor... pi2-&gt;pSecurityDescriptor = NULL; //２．続いて、１で取得した現在の DEVMODE から、値を変更（例えば、dmOrientation の値など）した //DEVMODE を SetPrinter でセットします。この時、レジストリが更新されます。 // Update printer information... bFlag = SetPrinter(hPrinter, 2, (LPBYTE)pi2, 0); if (!bFlag) // The driver doesn&#x27;t support, or it is unable to make the change... &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; //３．最後に 1 で取得した現在の DEVMODE をそのまま、SetPrinter でセットし、値を元に戻し、かつレジストリも再度更新します。 bFlag = SetPrinter(hPrinter, 2, (LPBYTE)pi2_org, 0); if (!bFlag) &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; // Tell other apps that there was a change... SendMessageTimeout(HWND_BROADCAST, WM_DEVMODECHANGE, 0L, (LPARAM)(LPCSTR)pPrinterName, SMTO_NORMAL, 1000, NULL); // Clean up... if (pi2_org) GlobalFree(pi2_org); if (pi2) GlobalFree(pi2); if (hPrinter) ClosePrinter(hPrinter); if (pDevMode) GlobalFree(pDevMode); return TRUE;&#125; 参考情報SetPrinter 関数GetPrinter 関数DEVMODEW 構造体 変更履歴2022&#x2F;09&#x2F;20 created by mitsuchi ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"devmode","slug":"devmode","permalink":"https://jpwdkblog.github.io/blog/tags/devmode/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"UWP アプリから nul ポートが指定されているプリンターに印刷できない","slug":"printer-null-port-issue","date":"2022-03-10T08:30:00.000Z","updated":"2025-10-01T07:16:53.354Z","comments":true,"path":"2022/03/10/printer-null-port-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2022/03/10/printer-null-port-issue/","excerpt":"この記事では、Windows 10 における印刷における問題について説明します。","text":"この記事では、Windows 10 における印刷における問題について説明します。 概要現在、Windows 10 の 2021 年 12 月 14 日— KB5008212 (OS ビルド 19041.1415、19042.1415、19043.1415、および 19044.1415) を適用した環境において、UWP アプリから nul: ポートが指定されているプリンターで印刷が失敗することを確認しています。 現象次のような条件で問題が発生します。 プリンターのプロパティにて、プリンター ポートとして次のように nul: が指定されています。 [フォト] などの UWP ベースのアプリから印刷します。 その結果、次のようなエラーが発生します。 解決方法2022&#x2F;6&#x2F;2 の更新プログラム KB5014023 (OS Builds 19042.1741, 19043.1741, and 19044.1741) にて、この問題について者は修正されました。 June 2, 2022—KB5014023 (OS Builds 19042.1741, 19043.1741, and 19044.1741) Preview https://support.microsoft.com/en-us/topic/june-2-2022-kb5014023-os-builds-19042-1741-19043-1741-and-19044-1741-preview-65ac6a5d-439a-4e88-b431-a5e2d4e2516a 変更履歴2022/03/10 created by riwaida2022/10/02 modified by riwaida: 更新プログラムの情報追加 ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"Windows 10","slug":"Windows-10","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-10/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Windows 11 における USB スキャナーで発生する問題について","slug":"win11-usbscan-issue","date":"2021-12-28T00:00:00.000Z","updated":"2025-10-01T07:16:53.485Z","comments":true,"path":"2021/12/28/win11-usbscan-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2021/12/28/win11-usbscan-issue/","excerpt":"この記事では、Windows 11 に USB スキャナーを接続した問題について説明します。","text":"この記事では、Windows 11 に USB スキャナーを接続した問題について説明します。 概要現在、Windows 11 において、次のような操作を行うと USB スキャナーのドライバーのロードに失敗して、スキャナーが正しく動作しない問題があることを確認しています。 (1) Windows が起動している状態で USB スキャナーを接続します。 (2) スキャナーと PC が接続されている USB ケーブルを抜く、またはスキャナーの電源をオフにします。 (3) Windows を再起動します。 (4) Windows 起動後、再度 USB スキャナーを接続、あるいは電源をオンにします。 結果：USB スキャナーを使用するアプリケーションを起動し、スキャナーの利用を試みると、スキャナー ドライバーの有無に関わらず [このデバイスを使用するには WIA ドライバーが必要です。] というエラーが表示されます。 状況この現象については Windows 11 の不具合であり 2022&#x2F;9&#x2F;20 に公開された更新プログラム KB5017383 (OS Build 22000.1042) 以降で修正されました。 September 20, 2022—KB5017383 (OS Build 22000.1042) Previewhttps://support.microsoft.com/en-us/topic/september-20-2022-kb5017383-os-build-22000-1042-preview-62753265-68e9-45d2-adcb-f996bf3ad393 開発者向け詳細情報この現象による問題かどうかについては c:\\windows\\debug\\WIA\\wiatrace.log を参照することで、判断することができます。Windows 11 において、ドライバーをインストールしているにもかかわらず、概要に記載のようなエラーが表示される場合、WIA Trace Log に次のようなログが出力されていないかご確認ください。USDWrapper::LoadDriver のエラーコードとして hr = 0x80070057 が記録されている場合、この現象に該当していると考えられます。 12WIA: xxxx.yyy zzz 0 0 [wiaservc.dll] ERROR: USDWrapper::LoadDriver, We encountered an error attempting to load driver for (YourScannerName), error (0x80070057)WIA: xxxx.yyy zzz 0 0 [wiaservc.dll] ERROR: DeviceListManager::ProcessDeviceArrival, The driver for device (YourScannerName) failed to load (hr = 0x80070057) 変更履歴2021/12/31 created by riwaida2022/10/20 modified by riwaida : 更新プログラムの情報追加 ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"Windows 11","slug":"Windows-11","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Windows 11 及び Server 2022 用 HLK の Create project のダイアログの \"Is Windows Driver Project?\" にチェックは入れないでください","slug":"HLK-create-project","date":"2021-07-12T15:00:00.000Z","updated":"2025-10-01T07:16:53.207Z","comments":true,"path":"2021/07/13/HLK-create-project/","link":"","permalink":"https://jpwdkblog.github.io/blog/2021/07/13/HLK-create-project/","excerpt":"Windows 11 及び Server 2022 用 HLK の Create project を実行する際の、”Is Windows Driver Project?” チェックボックスについて注意点を紹介いたします。","text":"Windows 11 及び Server 2022 用 HLK の Create project を実行する際の、”Is Windows Driver Project?” チェックボックスについて注意点を紹介いたします。 Windows 11 HLK 及び Windows HLK for Windows Server 2022 では、「手順 4:プロジェクトの作成」の際に、以下のような “Is Windows Driver Project?” というチェックボックスがある “Create project” のダイアログが表示されます。 誠に恐れ入りますが、Windows 11 や Windows Server 2022 用の認定や署名の取得のために、Hardware Dev Center Dashboard に提出される場合には、このチェックボックスに チェックは入れない ようにお願いいたします。 このチェックボックスは、本来 Dashboard へのご提出用を目的としておらず、弊社開発部門等と協業されているお客様が、その担当部門より指示があった場合にご利用されるものとなっており、将来削除予定となっております。 もしこれをチェックしてプロジェクトを作成して提出された場合、Hardware Dev Center Dashboard 側ではそれを処理できず、ご提出は Pass せず止まったまま、もしくは、Dashboard 側の担当部門にて Cancel の取り扱いとなります。この場合、Windows 11 HLK 及び Windows HLK for Windows Server 2022 でのご提出をご要望される場合は、以下のいずれかの対処策があります。 (a) 上記プロジェクトの作成をチェックボックスにチェックを入れずにやり直し、DF - InfVerif INF Verification (bbcc1b46-d0bf-46c8-85b4-2cd62df34a20) のみ実施します。そして、HLK Studio の Package タブの [Add Supplemental Folder] ボタンでSupplemental folder に以下を追加した提出パッケージを作成します。 上記の提出が Pass しなかった HLKX ファイル Waiver ID Number に 84015 (という Manual Errata ID) をご記載いただいた、WHQL Submission Readme フォーム (b) 万が一、何らかの理由で (a) の方法がうまくいかない場合は、上記プロジェクトの作成からチェックを入れずにやり直し、テストを全て再度ご実施いただきます。 上記の問題を弊社は認識しておりますため、改善に向けたアクションを進めております。ただ、誠に恐れ入りますが、現時点では、上記の回避策があるため、Windows 11 HLK 及び Windows HLK for Windows Server 2022 そのものの修正は行われず、次のバージョンのリリースに修正が含まれる予定です。そのため、誠にお手数ではございますが、Windows 11 HLK 及び Windows HLK for Windows Server 2022 につきましては、上記の対処でのご対応をお願い申し上げます。 参考 URLWindows 11 &amp; Server 2022 HLK kit guidance for creating new submission packages for Widows 11, v21H2 変更履歴2021/07/13 created by Tsuda2021/07/20 modified by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Hardware Lab Kit","slug":"Hardware-Lab-Kit","permalink":"https://jpwdkblog.github.io/blog/categories/Hardware-Lab-Kit/"}],"tags":[{"name":"Windows 11 HLK","slug":"Windows-11-HLK","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11-HLK/"}],"keywords":[{"name":"Hardware Lab Kit","slug":"Hardware-Lab-Kit","permalink":"https://jpwdkblog.github.io/blog/categories/Hardware-Lab-Kit/"}]},{"title":"Windows PE 用ドライバの開発において参考になる公開ドキュメントについて","slug":"winpe-reference-websites","date":"2020-08-11T03:00:00.000Z","updated":"2025-10-01T07:16:53.538Z","comments":true,"path":"2020/08/11/winpe-reference-websites/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/08/11/winpe-reference-websites/","excerpt":"Windows PE で動作するドライバを開発していただくにあたり、ご参照いただける公開ドキュメントをこちらにまとめてご紹介をいたします。","text":"Windows PE で動作するドライバを開発していただくにあたり、ご参照いただける公開ドキュメントをこちらにまとめてご紹介をいたします。 これをご案内する背景として、上記を実現するために必要な公開情報はあるものの、Windows PE で動作するドライバを開発する、という目的で一元化してはおりませんため、それらをおまとめした今回のブログがお役に立てば幸いです。 ドライバの実装そのものに Windows PE のために特別必要な実装はございませんので、インストール方法とデバッグ方法について以下の通りご案内いたします。 ドライバのインストール方法 Add and Remove Drivers to an offline Windows Image Add Device Drivers to Windows During Windows Setup WinPE:マウントとカスタマイズ デバイス ドライバー (.inf ファイル) を追加する WinPE イメージにデバイス ドライバーを追加するには、DISM &#x2F;add-driver を使用します。 Dism &#x2F;Add-Driver &#x2F;Image:”C:\\WinPE_amd64\\mount” &#x2F;Driver:”C:\\SampleDriver\\driver.inf” 1 つのコマンドを使用してイメージに複数のドライバーを追加できますが、ほとんどの場合、各ドライバー パッケージを個別に追加すると問題のトラブルシューティングが簡単になります。ドライバーの詳細については、デバイス ドライバー (.inf ファイル) の追加 に関するページを参照してください。 使用可能なすべての DISM ドライバー サービス オプションを確認するには、DISM ドライバー サービスのコマンド ライン オプション に関するページを参照してください。 Drvload Command-Line Options The Drvload tool adds out-of-box drivers to a booted Windows Preinstallation Environment (Windows PE) image. It takes one or more driver .inf files as inputs. To add a driver to an offline Windows PE image, use the Deployment Image Servicing and Management (DISM) tool. For more information, see Add and Remove Drivers to an Offline Windows Image. If the driver .inf file requires a reboot, Windows PE will ignore the request. If the driver .sys file requires a reboot, then the driver cannot be added with Drvload. For more information, see Device Drivers and Deployment Overview and DISM Driver Servicing Command-Line Options. Drivers added using the Drvload tool are marked as the preferred driver for that device. If you add an updated driver during Windows Setup, the driver that you added with Drvload takes precedence. ドライバのデバッグ方法 WinPE: Debug Apps - Kernel-mode debugging 上記に関連して、以下のブログも作成しておりますので、ご参考になりましたら幸いです。 Windows PE でのネットワーク経由カーネル デバッガ接続方法について Windows PE で IOCTL サンプルを動作させる方法について 以上の内容がお役に立てば幸いです。 変更履歴2020/08/11 created by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}],"tags":[{"name":"参考情報","slug":"参考情報","permalink":"https://jpwdkblog.github.io/blog/tags/%E5%8F%82%E8%80%83%E6%83%85%E5%A0%B1/"}],"keywords":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}]},{"title":"Windows PE で IOCTL サンプルを動作させる方法について","slug":"IOCTL-sample","date":"2020-07-29T08:30:00.000Z","updated":"2025-10-01T07:16:53.256Z","comments":true,"path":"2020/07/29/IOCTL-sample/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/07/29/IOCTL-sample/","excerpt":"Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。","text":"Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。 今回は、Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。 IOCTL サンプル サイト Windows PE でご自身のドライバがうまく動作しない場合の、比較の一助になれば幸いです。 前提今回は、以前ご案内した以下のブログと同じ環境がすでにあることを前提とします。 Windows PE でのネットワーク経由のカーネルデバッガ接続方法 上記で使用している ISO を上書きすることになるため、仮想マシンはシャットダウン (電源 OFF でもよいです) し、カーネルデバッガも終了しておきます。また、今回はあくまでもテスト目的のため、通常必要となる以下の方法での INF ファイルのドライバインストール方法を使っていない点にご留意ください。 WinPE:マウントとカスタマイズ - デバイス ドライバー (.inf ファイル) を追加する 今回使用する IOCTL のサンプルにも、運用環境で使用してはいけない旨記載されております。 IOCTL サンプル サイト 抜粋: [!CAUTION] This sample driver is not a Plug and Play driver. This is a minimal driver meant to demonstrate a feature of the operating system. Neither this driver nor its sample programs are intended for use in a production environment. Instead, they are intended for educational purposes and as a skeleton driver. 手順(1) IOCTL サンプルを Visual Studio 2019 で x64 &#x2F; Debug でビルドします。 1-1. サンプルの入手 IOCTL サンプルは、以下のサイトの右側の緑色の [Code] ボタンを押すと表示される [Download ZIP] ボタンで Windows-driver-samples-master.zipをダウンロードすると、Windows-driver-samples-master\\general\\ioctl\\wdm のフォルダにあります。 https://github.com/Microsoft/Windows-driver-samples 1-2. サンプルのビルド このフォルダの ioctl.sln を、Visual Studio 2019 で開きます。Exe フォルダの下にはユーザーモードアプリケーションである ioctlapp のプロジェクト、Sys フォルダの下にはカーネルモードドライバである sioctl のプロジェクトがあることを確認できます。 [ソリューション ‘ioctl’] を右クリックして [構成マネージャー] をクリックします。 今回は、[アクティブソリューション構成] を **[Debug]**、[アクティブ ソリューション プラットフォーム] を [x64] とします。 また、ioctlapp のプロパティを開き、[構成プロパティ]-[C&#x2F;C++]-[コード生成] の [ランタイム ライブラリ] は [マルチスレッド デバッグ (&#x2F;MTd)] にしておきます。 [ソリューション ‘ioctl’] を右クリックして [ソリューションのリビルド] をクリックします。 これで、ioctlapp.exe, sioctl.sys ができます。 次のステップに必要なファイルと場所は以下です。 ファイル 場所 ioctlapp.exe&amp;nbsp;&amp;nbsp;&amp;nbsp; ioctl\\wdm\\exe\\x64\\Debug sioctl.sys&amp;nbsp;&amp;nbsp;&amp;nbsp; ioctl\\wdm\\sys\\x64\\Debug (2) 管理者権限で起動された [展開およびイメージング ツール環境] で、以下のコマンドを実行します。(作業用ディレクトリは、前回の記事の前提のまま D:\\WinPE_amd64 とします。) 2-1. テスト署名が利用可能になるようにします。 1&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /set &#123;default&#125; testsigning on 2-2. 上述のアプリケーションとドライバのファイルを WinPE のイメージにコピーするために、WinPE のイメージをマウントします。 1&gt; Dism /Mount-Image /ImageFile:&quot;D:\\WinPE_amd64\\media\\sources\\boot.wim&quot; /index:1 /MountDir:&quot;D:\\WinPE_amd64\\mount&quot; 参考: Windows PE ブート イメージをマウントする 2-3. マウントした WinPE のイメージに、上述のアプリケーションとドライバのファイルをコピーします。ここでは例として \\Windows\\Ioctl というフォルダにコピーするとします。 123&gt; xcopy D:\\develop\\blog\\ioctl\\wdm\\sys\\x64\\Debug\\sioctl.sys &quot;D:\\WinPE_amd64\\mount\\Windows\\Ioctl&quot;&gt; xcopy D:\\develop\\blog\\ioctl\\wdm\\exe\\x64\\Debug\\ioctlapp.exe &quot;D:\\WinPE_amd64\\mount\\Windows\\Ioctl&quot; 2-4. WinPE イメージのマウントを解除し、変更をコミットします。 1&gt; Dism /Unmount-Image /MountDir:&quot;D:\\WinPE_amd64\\mount&quot; /commit 参考: Windows PE イメージのマウントを解除し、メディアを作成する 2-5. 上記が完了したら、以下のコマンドで Windows PE の ISO ファイルを作成します。 1&gt; makewinpemedia /iso d:\\WinPE_amd64\\winpe_x64_debug.iso (3) 「Windows PE でのネットワーク経由のカーネルデバッガ接続方法」の記事で作成した仮想マシンを起動すると、上記の ISO ファイルで起動します。 (4) カーネルデバッガ側は、以下のコマンドを実行することで Windows PE のターゲットにデバッガ接続し、ブレークインできます。 1&gt; windbg.exe -k net:port=50005,key=5.5.5.5 (5) カーネルデバッガ側では、Symbol Search Path に上記 1-2. の sioctl.sys と ioctlapp.exe のシンボルファイル (sioctl.pdb と ioctlapp.pdb) の存在するフォルダへのフルパスを追記しておきます。 (6) カーネルデバッガの Commands ウィンドウで以下のコマンドを実行して、sioctl.sys の DriverEntry にブレークポイントを貼ってから g を実行します。 1&gt; bp sioctl!DriverEntry (7) 仮想マシン上で開いているコマンドプロンプト上で、以下を実行します。 7-1. ioctlapp.exe のある \\Windows\\Ioctl フォルダに移動します。 1&gt; cd \\Windows\\Ioctl 7-2. ioctlapp.exe をオプションなしで実行します。 1&gt; ioctlapp.exe (8) カーネルデバッガ側で sioctl!DriverEntry にブレークインします。自動的に ioctl\\wdm\\sys\\sioctl.c が開かない場合には開きます。 (9) Commands ウィンドウで p などを入力して、161 行目の「return status;」までステップ実行します。ここで、!drvobj sioctl 2 と実行すれば、132 行目で「DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] &#x3D; SioctlCreateClose;」を実行している通り、以下のように、IOCTL_MJ_CREATE のコールバックに SIoctl!SioctlCreateClose がセットされていることがわかります。 1234567891011121314151617181920212223242526272829303132333435363738kd&gt; !drvobj sioctl 2Driver object (ffffd18d336f0e40) is for:\\Driver\\SIoctlDriverEntry: fffff80822a76150 SIoctl!GsDriverEntryDriverStartIo: 00000000 DriverUnload: fffff80822a759e0 SIoctl!SioctlUnloadDriverAddDevice: 00000000 Dispatch routines:[00] IRP_MJ_CREATE fffff80822a751d0 SIoctl!SioctlCreateClose &lt;&lt;&lt;&lt;&lt; ★[01] IRP_MJ_CREATE_NAMED_PIPE fffff80627dccd40 nt!IopInvalidDeviceRequest[02] IRP_MJ_CLOSE fffff80822a751d0 SIoctl!SioctlCreateClose[03] IRP_MJ_READ fffff80627dccd40 nt!IopInvalidDeviceRequest[04] IRP_MJ_WRITE fffff80627dccd40 nt!IopInvalidDeviceRequest[05] IRP_MJ_QUERY_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[06] IRP_MJ_SET_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[07] IRP_MJ_QUERY_EA fffff80627dccd40 nt!IopInvalidDeviceRequest[08] IRP_MJ_SET_EA fffff80627dccd40 nt!IopInvalidDeviceRequest[09] IRP_MJ_FLUSH_BUFFERS fffff80627dccd40 nt!IopInvalidDeviceRequest[0a] IRP_MJ_QUERY_VOLUME_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[0b] IRP_MJ_SET_VOLUME_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[0c] IRP_MJ_DIRECTORY_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[0d] IRP_MJ_FILE_SYSTEM_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[0e] IRP_MJ_DEVICE_CONTROL fffff80822a75250 SIoctl!SioctlDeviceControl[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[10] IRP_MJ_SHUTDOWN fffff80627dccd40 nt!IopInvalidDeviceRequest[11] IRP_MJ_LOCK_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[12] IRP_MJ_CLEANUP fffff80627dccd40 nt!IopInvalidDeviceRequest[13] IRP_MJ_CREATE_MAILSLOT fffff80627dccd40 nt!IopInvalidDeviceRequest[14] IRP_MJ_QUERY_SECURITY fffff80627dccd40 nt!IopInvalidDeviceRequest[15] IRP_MJ_SET_SECURITY fffff80627dccd40 nt!IopInvalidDeviceRequest[16] IRP_MJ_POWER fffff80627dccd40 nt!IopInvalidDeviceRequest[17] IRP_MJ_SYSTEM_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[18] IRP_MJ_DEVICE_CHANGE fffff80627dccd40 nt!IopInvalidDeviceRequest[19] IRP_MJ_QUERY_QUOTA fffff80627dccd40 nt!IopInvalidDeviceRequest[1a] IRP_MJ_SET_QUOTA fffff80627dccd40 nt!IopInvalidDeviceRequest[1b] IRP_MJ_PNP fffff80627dccd40 nt!IopInvalidDeviceRequest (10) カーネルデバッガの Commands ウィンドウで以下のコマンドを実行して、sioctl.sys の SioctlCreateClose にブレークポイントを貼ってから g を実行します。 1&gt; bp sioctl!SioctlCreateClose (11) カーネルデバッガ側で SIoctl!SioctlCreateClose にブレークインします。k を実行すると、確かに ioctlapp.exe の main 関数の CreateFile からオープンされたことが確認できます。 1234567891011121314151617kd&gt; k# Child-SP RetAddr Call Site00 ffff9088`d85c73d8 fffff806`27cceda9 SIoctl!SioctlCreateClose [D:\\develop\\blog\\ioctl\\wdm\\sys\\sioctl.c @ 192] 01 (Inline Function) --------`-------- nt!IopfCallDriver+0x4402 ffff9088`d85c73e0 fffff806`27ccde54 nt!IofCallDriver+0x5903 ffff9088`d85c7420 fffff806`282b9b6b nt!IoCallDriverWithTracing+0x3404 ffff9088`d85c7470 fffff806`282c09af nt!IopParseDevice+0x62b05 ffff9088`d85c75e0 fffff806`282bee11 nt!ObpLookupObjectName+0x78f06 ffff9088`d85c77a0 fffff806`282d99aa nt!ObOpenObjectByNameEx+0x20107 ffff9088`d85c78e0 fffff806`282d9599 nt!IopCreateFile+0x3fa08 ffff9088`d85c7980 fffff806`27e74e95 nt!NtCreateFile+0x7909 ffff9088`d85c7a10 00007ffc`ff25cb04 nt!KiSystemServiceCopyEnd+0x250a 000000ae`5e8ff408 00007ffc`fd1c45e4 ntdll!ZwCreateFile+0x140b 000000ae`5e8ff410 00007ffc`fd1c422f KERNELBASE!CreateFileInternal+0x2f40c (Inline Function) --------`-------- KERNELBASE!CreateFileW+0x6a0d 000000ae`5e8ff580 00007ff7`9ec81cd2 KERNELBASE!CreateFileA+0xbf0e 000000ae`5e8ff5f0 00000000`00000000 ioctlapp!main+0x142 [D:\\develop\\blog\\ioctl\\wdm\\exe\\testapp.c @ 106] Testapp.c の 106 行目のコードは、確かに以下の通り CreateFile() を実行しています。 これでオープンできているのは、sioctl.sys で以下のように、IoCreateDevice() の第 3 引数 ntUnicodeString で \\Device\\SIOCTL という NT Device Name をセットしており、かつ、これに対するシンボリックリンクとして、Win32 Name である \\DosDevices\\IoctlTest を IoCreateSymbolicLink() で作成しているためです。 参考:Introduction to MS-DOS Device Names ただ、上記のドキュメントにも以下の抜粋の様にある通り、上記の方法を取るのは、一般には非 WDM ドライバです。WDM ドライバは一般的にはデバイスインターフェースを登録して使用します。 抜粋： A named device object that is created by a non-WDM driver typically has an MS-DOS device name. An MS-DOS device name is a symbolic link in the object manager with a name of the form \\DosDevices\\DosDeviceName. WDM drivers do not usually supply MS-DOS device names for their devices. Instead, WDM drivers use the IoRegisterDeviceInterface routine to register a device interface. The device interface specifies devices by their capabilities, rather than by a particular naming convention. For more information, see Device Interface Classes. KMDF など WDF については、以下のドキュメントもご参考ください。Using Device Interfaces (12) 最終的に仮想マシン上のコマンドプロンプトには、ioctlapp.exe の実行結果として、以下が表示されて、問題なく動作できていることがわかります。(各 IOCTL の動作を確認したい場合は、上記を参考に SIoctl!SioctlDeviceControl にブレークポイントを貼ってみてください。) 以上の内容がお役に立てば幸いです。 変更履歴2020/07/29 created by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}],"tags":[{"name":"IOCTL","slug":"IOCTL","permalink":"https://jpwdkblog.github.io/blog/tags/IOCTL/"}],"keywords":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}]},{"title":"Windows PE でのネットワーク経由カーネル デバッガ接続方法について","slug":"winpe-kernel-debug-via-network","date":"2020-07-29T08:00:00.000Z","updated":"2025-10-01T07:16:53.514Z","comments":true,"path":"2020/07/29/winpe-kernel-debug-via-network/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/07/29/winpe-kernel-debug-via-network/","excerpt":"Windows PE でのネットワーク経由のカーネルデバッガ接続方法についてご紹介します。","text":"Windows PE でのネットワーク経由のカーネルデバッガ接続方法についてご紹介します。 Windows PE でのシリアルケーブル経由でのカーネルデバッガ接続方法は、以下のドキュメントが公開されております。この方法では、カーネルデバッガを起動する側であるホスト PC を選びません。 WinPE: Debug Apps - Kernel-mode debugging 対しまして、今回ご紹介するネットワーク経由のカーネルデバッガ接続方法では、通常、以下のブログでご紹介したような kdnet.exe は、ターゲット PC の再起動が必要となるため使えず、予めホスト PC の IP アドレスを Windows PE 側の BCD に設定しておく必要があります。 Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法 それでは、具体的な手順を紹介します。 前提今回は、Windows PE のイメージ作成を行う環境と、カーネルデバッガを起動するホスト PC は同じ PC とします。そして、その PC の Hyper-V 仮想マシン (UEFI を使うため第二世代、セキュアブートは OFF) を、ターゲット PC として、Windows PE の ISO を読ませるようにします。 ホスト PC には、以下のリンクから、Windows ADK for Windows 10 バージョン 1903 と、ADK 用の Windows PE アドオンをインストールしています。 Windows ADK のダウンロードとインストール Windows ADK for Windows 10、バージョン 1903 のダウンロード ADK 用の Windows PE アドオンのダウンロード 手順(1) [スタート] -&gt; [Windows Kits] -&gt; [展開およびイメージング ツール環境] を管理者権限で起動します。 (2) copype.exe で、例として D:\\WinPE_amd64 に作業用ディレクトリを作成します。(D ドライブの使用は例であり、任意の場所で問題ありません。また、すでに D:\\WinPE_amd64 が存在する場合は、コマンドがエラーとなるため、事前に削除しておきます。) 1&gt; copype amd64 d:\\WinPE_amd64 (3) 以下のコマンドを実行し、Windows PE 環境側のネットワーク接続でのカーネルデバッグ設定を行います。 (3-A) Windows PE 環境が UEFI の場合 12345&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /set &#123;default&#125; debug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /set &#123;default&#125; bootdebug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /dbgsettings NET HOSTIP:&lt;カーネルデバッガを起動するホスト PC の IP アドレス、xxx.xxx.xxx.xxx&gt; PORT:50005 key:5.5.5.5 (3-B) Windows PE 環境がレガシー BIOS の場合 12345&gt; bcdedit /store d:\\WinPE_amd64\\media\\Boot\\BCD /set &#123;default&#125; debug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\Boot\\BCD /set &#123;default&#125; bootdebug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\Boot\\BCD /dbgsettings NET HOSTIP:&lt;カーネルデバッガを起動するホスト PC の IP アドレス、xxx.xxx.xxx.xxx&gt; PORT:50005 key:5.5.5.5 PORT の 50005 と key の 5.5.5.5 は例です。 (4) 以下のコマンドを実行し、設定した結果に問題ないか確認します。 123456&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /dbgsettings key 5.5.5.5 debugtype NET hostip xxx.xxx.xxx.xxx port 50005 dhcp Yes (5) 上記が完了したら、以下のコマンドで Windows PE の ISO ファイルを作成します。 1&gt; makewinpemedia /iso d:\\WinPE_amd64\\winpe_x64_debug.iso (6) 上記の ISO ファイルで Hyper-V 仮想環境 (第二世代、セキュアブートなし) を作成します。 (上記の手順 (3) で、(3-A) で設定を行ったことが前提です。第一世代ですと、UEFI ではないため、(3-B) でないとカーネルデバッグ接続できません。また、セキュアブートは無効にする必要があります。) 使用する仮想スイッチは、上記「Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法」の「1. ホストPC と仮想マシンをネットワーク接続します。」と同じものを使っています。 (7) カーネルデバッガ側は、以下のコマンドを実行することで Windows PE のターゲットにデバッガ接続し、ブレークインできます。 1&gt; windbg.exe -k net:port=50005,key=5.5.5.5 以上の内容がお役に立てば幸いです。 変更履歴2020/07/29 created by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}],"tags":[{"name":"カーネル デバッグ","slug":"カーネル-デバッグ","permalink":"https://jpwdkblog.github.io/blog/tags/%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB-%E3%83%87%E3%83%90%E3%83%83%E3%82%B0/"}],"keywords":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}]},{"title":"過去ブログについて","slug":"past-blog","date":"2020-01-11T15:00:00.000Z","updated":"2025-10-01T07:16:53.275Z","comments":true,"path":"2020/01/12/past-blog/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/01/12/past-blog/","excerpt":"過去のブログ情報を紹介いたします。","text":"過去のブログ情報を紹介いたします。 WDKWindows Driver Kit サポートチーム フォーラム 抜粋: Windows 10 IoT Core 環境の COM ポートの割り当てについて WIA ミニドライバーサンプル wiadriverex をデバッグする Visual Studio 2015 でのテスト署名方法 カーネルモード デバッガで UMDF ドライバをライブデバッグする V4 プリンター ドライバのデバッガアタッチ方法 デバイスマネージャーの [表示] を [デバイス (接続別)] に切り替える ダンプファイルに保存されたイベントログを取り出す ダンプファイルに保存された ETW トレースログを表示するなど 旧: Japan WDK Support Blog 抜粋: Japan WDK Support Blog 終了のお知らせ Authenticode 署名のドライバインストールのトラブルシューティングの一例 プリンタードライバーの GPD ファイル記述に関する注意事項 Time Travel Debugging (Preview) の Lab Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法 WDK for Windows 10, version 1803 Err.exe でエラーコードの定義を探す Minispy File System Minifilter Driver サンプルを動かしてみるなど 変更履歴2020/01/12 created by Mochizuki2021/04/01 created by Mochizuki ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}],"tags":[{"name":"過去ブログ","slug":"過去ブログ","permalink":"https://jpwdkblog.github.io/blog/tags/%E9%81%8E%E5%8E%BB%E3%83%96%E3%83%AD%E3%82%B0/"}],"keywords":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}]},{"title":"jpwdkblog について","slug":"aobut-jpwdkblog","date":"2019-12-31T15:00:00.000Z","updated":"2025-10-01T07:16:53.185Z","comments":true,"path":"2020/01/01/aobut-jpwdkblog/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/01/01/aobut-jpwdkblog/","excerpt":"","text":"日本マイクロソフトの Windows Driver Kit に関するサポート情報のブログです。 公開日2020 年 1 月 1 日より公開いたしました。 活動について製品のサポート メンバーによって運用されております。仕様に関する情報やトラブル シューティングの手順、実装におけるワンポイント アドバイスを公開いたします。 留意事項サイトのコンテンツや情報において、可能な限り正確な情報を掲載し、更新するよう努めております。しかしながら、状況の変化や情報が古くなることにより、必ずしもお客様環境に適用できない情報となる場合がございます。恐れ入りますが、予めご留意くださいますようお願い申し上げます。","categories":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}],"tags":[{"name":"はじめに","slug":"はじめに","permalink":"https://jpwdkblog.github.io/blog/tags/%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB/"}],"keywords":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}]}]}