{"meta":{"title":"Japan WDK Support Blog","subtitle":"","description":"","author":"jpwdkblog","url":"https://jpwdkblog.github.io/blog"},"pages":[],"posts":[{"title":"第1回：WFP を理解する ― カーネルコールアウトドライバー実装の土台","slug":"wfp_calloutr_driver_part1","date":"2026-02-04T15:00:00.000Z","updated":"2026-02-05T09:21:50.232Z","comments":true,"path":"2026/02/05/wfp_calloutr_driver_part1/","link":"","permalink":"https://jpwdkblog.github.io/blog/2026/02/05/wfp_calloutr_driver_part1/","excerpt":"この記事では、Windows Filtering Platform (WFP) のカーネルコールアウトドライバー実装に初めて取り組む開発者向けに、理解すべき土台と構造を “迷わず” 把握できるよう整理します。単なる API 羅列ではなく、なぜその設計が必要なのか／実装者はどの位置に立つのかをクリアにすることを目的としています。","text":"この記事では、Windows Filtering Platform (WFP) のカーネルコールアウトドライバー実装に初めて取り組む開発者向けに、理解すべき土台と構造を “迷わず” 把握できるよう整理します。単なる API 羅列ではなく、なぜその設計が必要なのか／実装者はどの位置に立つのかをクリアにすることを目的としています。 1. WFP は何を提供する仕組みなのかWFP は Windows ネットワークスタックに対する 統一的なフィルタリング基盤です。旧来の TDI や LSP、NDIS フィルター ドライバーといった複数のレイヤーで分断された仕組みを置き換え、以下を単一の機能で扱えるようにしています。 パケット単位／ストリーム単位での検査・変更 IPv4 &#x2F; IPv6 双方のサポート アプリケーション単位、ユーザー単位、コネクション単位でのポリシー制御 IPsec、RPC を含む幅広いレイヤーでの分類 特に開発者にとって重要なのは、カーネルでの高速分類とコールアウトによる拡張が可能な点です。コールアウトドライバーは、特定レイヤーで到達したネットワーク データに対し、カスタム処理（深い検査、変更、再注入など）を行うことができます。 WFP のコールアウトはフックに近い処理となります。NDIS フィルター ドライバーの場合、プロトコル スタック - NDIS ミニポート ドライバー間のパケットの通過経路（データパス）へインライン処理として追加されるのに対して、WFP のコールアウトは、WFP の場合はパケットの分類処理に割り込んで処理が行われるというイメージです。 2. WFP のアーキテクチャを “位置関係” で理解するWFP の中心には BFE (Base Filtering Engine) があり、ユーザーモードとカーネルモード双方に分類エンジンを持ちます。 ユーザーモード フィルター エンジン：RPC、IPsec などを担当（約10レイヤー） カーネルモード フィルター エンジン：TCP&#x2F;IP スタックのネットワーク／トランスポート層（約50レイヤー）👉 各レイヤーの一覧はこちら Filtering Layer Identifiers &#x2F; Fwpmu.h フィルタリングはこのエンジン上で行われ、以下の構成要素から成り立ちます。 Filter（フィルター）条件とアクション（許可・拒否・コールアウト呼び出しなど）を定義したルール。複数条件を持つ複合フィルターも作成できます。※フィルターはドライバー ソフトウェアを指しているのではなく、挙動を決定する定義です。 Sublayer（サブレイヤー）フィルター同士の競合を整理し、優先順位（ウェイト）を設定するための論理的なレイヤー。コールアウト ドライバーは自身のサブレイヤーを持つのが一般的です。 Callout（コールアウト）分類処理の中で呼び出される “拡張ポイント”。コールアウト ドライバーは以下のような用途を実現します。開発者にとってコールアウトはネットワーク スタックにフックを追加する最小単位であり、分類のたびに classifyFn が実行されます。 深いパケット検査（Deep Inspection） パケット／ストリームデータの変更と再注入 データのログ収集 3. FWPM（管理）と FWPS（実行）の違いを最初に押さえるWFP では 管理プレーン（FWPM） と 実行プレーン（FWPS） の API が明確に分離されています。以下は、具体的な API 例です。 Fwpm（管理プレーン：ユーザーモード）ユーザーモードサービスが 「WFP の設定を登録する側」 を担当します。 役割 エンジンのオープン、サブレイヤー追加、フィルター追加の削除 トランザクション（Begin &#x2F; Commit &#x2F; Abort） 代表的な関数一覧 関数名 説明 FwpmEngineOpen0 BFE（Base Filtering Engine）への接続を開く FwpmSubLayerAdd0 独自サブレイヤーを登録する FwpmCalloutAdd0 コールアウト定義を管理プレーンに追加する FwpmFilterAdd0 フィルターを追加し WFP に適用する FwpmFilterDeleteById0 フィルターを削除する FwpmTransactionBegin0, FwpmTransactionCommit0, FwpmTransactionAbort0 フィルター操作のトランザクション制御 Fwps（実行プレーン：カーネルモード）カーネルドライバー（コールアウトドライバー）が 「実際の分類処理に参加する側」 を担当します。 役割 classifyFn によるパケット分類、notifyFn による通知の受け取り、flowDeleteFn でのデータフローの停止時の処理 ストリーム／パケットのクローン・変更・再注入 メタデータ参照 コールアウト登録／解除 代表的な関数一覧 関数名 説明 FwpsCalloutRegister classifyFn &#x2F; notifyFn &#x2F; flowDeleteFn を登録 FwpsCalloutUnregisterByKey 登録解除 FwpsAllocateCloneNetBufferList0 パケット（NBL）のクローン生成（修正・再注入に使用） FwpsCopyStreamDataToBuffer0 ストリームデータを連続バッファへコピー FwpsInjectNetworkSendAsync0 パケットを再注入する FwpsAcquireClassifyHandle0, FwpsReleaseClassifyHandle0 分類メタデータにアクセスするためのハンドル取得／解放 まとめると、WFP の “設定” は FWPM、実際の “分類と処理” は FWPS と覚えておきます。 4. Callout Driver の構造（最小イメージ）カーネルコールアウトドライバーは、次のような実装を行います。ユーザーモード サービスによる管理を行うドライバーの場合は Fwpm** は通常は呼び出しません。 DriverEntry FwpsCalloutRegister によりコールアウトを登録 FwpmCalloutAdd／FwpmFilterAdd によるレイヤーの指定や、フィルター条件の設定（通常ユーザーモード サービス側で担当） FWPS_CALLOUT.classifyFn ネットワークデータ到達時に呼ばれるコア関数 パケット (およびネットワーク ストリーム) のチェック、変更、必要に応じて一時的に処理を保留、ブロック等を実行 FWPS_CALLOUT.notifyFn フィルターが追加されたり削除された時に通知を受信する関数。または BFE 状態が変化した際の通知を受け取る関数。 Packet&#x2F;Stream 操作の補助を関数 (ドライバー独自の関数)次のような各種処理を行う各種関数を用意し、その関数から Fwps API を呼び出します。 パケットクローン、再注入 ストリームデータのバッファコピー例：FwpsAllocateCloneNetBufferList0、FwpsCopyStreamDataToBuffer0 などを使用する処理 Unload 時のクリーンアップ FwpsCalloutUnregisterBy** で登録の解除 割り当てリソース解放 これらを KMDF &#x2F; WDM ドライバーいずれでも実装可能ですが、リソース管理の観点で KMDF での実装をお勧めします。 5. コールアウト処理の選択WFP のコールアウトは大きく3分類に分けられます。 Inline Inspection：トラフィックを変更せず観察だけを classifyFn 内で行う（action &#x3D; CONTINUE） Inline Modification：クローン → 加工 → パケットの再注入を classifyFn の中で実施 Out-of-band Inspection：一旦データを保留して、classifyFn の外部（専用のスレッドや、WorkItem、DPC ルーチン）で処理して、パケットの再注入を行う実装の難度と副作用の大きさは、Inline Inspection ＜ Inline Modification ＜ Out-of-band の順に上がります。まずは Inline Inspection で処理を理解し、その後、目的に応じてパケットの変更系に進むのが学習の流れとしては理解しやすいです。 それぞれの用途と、特徴は次の通りです。 種類 向いている用途 副作用の大きさ※ Inline Inspection ログ、監査、軽い条件分岐 小 Inline Modification NAT &#x2F; ヘッダ書換 中 Out-of-band ストリーム単位の解析・DLP 大 ※ここでの副作用とは、ドライバーの実装・設計ミスにより、OS のネットワーク挙動に生じる悪影響（遅延・通信断・高負荷・デッドロックなど）を指しています。 6. フィルター設定の “落とし穴” について初めにつまづきやすいポイントとしては、コールアウト側の実装ではなく フィルター側の設定ミスです。 フィルターの条件を詰め込み過ぎて分類遅延が発生 Weight や Sublayer の整合が取れず、期待より前に別のフィルターが介入 ALE (Application Layer Enforcement 層と Transport 層の理解不足により、期待しているレイヤーで classifyFn が呼ばれない特に ALE レイヤー（接続確立前後の処理）は、WinSock の listen &#x2F; bind &#x2F; connect &#x2F; accept のどの部分に該当するのかを理解しておくのが重要です。関連ドキュメント : ALE Layers ALE は Winsock API と対になるよう設計されており、大まかな図で表すと次のようになります。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Client-side ALE FlowApplication | | socket() vFWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4/V6 | | bind() vFWPM_LAYER_ALE_BIND_REDIRECT_V4/V6 (allows redirecting the socket’s local address/port for as long as the socket exists) | | connect() vFWPM_LAYER_ALE_CONNECT_REDIRECT_V4/V6 (allows modifying the remote address/port of an outbound connection) | vFWPM_LAYER_ALE_AUTH_CONNECT_V4/V6 (first outbound SYN / first UDP send) | vTCP 3-way handshake completes | vFWPM_LAYER_ALE_FLOW_ESTABLISHED_V4/V6 (flow created; tracking only) | vData phase (send/recv) | vFWPM_LAYER_ALE_ENDPOINT_CLOSURE_V4/V6 (FIN/RST / socket close)// Server-side ALE FlowApplication | | socket() vFWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4/V6 | | bind() vFWPM_LAYER_ALE_BIND_REDIRECT_V4/V6 (allows redirecting the socket’s local address/port for as long as the socket exists) | | listen() vFWPM_LAYER_ALE_AUTH_LISTEN_V4/V6 (listen call) | client connects | vFWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4/V6 (first inbound SYN / UDP first packet) |TCP 3-way handshake completes | vFWPM_LAYER_ALE_FLOW_ESTABLISHED_V4/V6 (after a TCP 3-way handshake has successfully completed) | vData phase (send/recv) | vFWPM_LAYER_ALE_ENDPOINT_CLOSURE_V4/V6 7. まとめ今回（第1回）では、WFP のコールアウト ドライバー実装に必要な基礎的な内容について整理しました。 ✔ 今回のポイント WFP の全体像（BFE &#x2F; ユーザーモード &#x2F; カーネルモード） FWPM（管理）と FWPS（実行）の違い コールアウト処理の種類と選び方 ALE レイヤーの流れと注意点（connect &#x2F; bind &#x2F; accept の扱い）WFP では分かりにくい点が多いですが、これらを押さえることでサンプルコードへの理解、実際にドライバーの作成・デバッグの役に立つものと思います。 次回（第2回）予告第2回のテーマ（予定）：実装編 基礎から実用へ コールアウトドライバーの最小コード（DriverEntry &#x2F; classifyFn） ユーザーモードサービスによるサブレイヤー・フィルター登録 netsh wfp、Security ログ、ETW を使った動作確認 Connect Redirect など、実案件でも役に立つシナリオ紹介 開発環境セットアップ（WDK &#x2F; テストサイン &#x2F; カーネルデバッグ）などを検討していますが、状況により変更となる可能性がありますことあらかじめご了承ください。 変更履歴2026/02/05 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Development","slug":"Development","permalink":"https://jpwdkblog.github.io/blog/categories/Development/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://jpwdkblog.github.io/blog/tags/Network/"},{"name":"WFP","slug":"WFP","permalink":"https://jpwdkblog.github.io/blog/tags/WFP/"}],"keywords":[{"name":"Development","slug":"Development","permalink":"https://jpwdkblog.github.io/blog/categories/Development/"}]},{"title":"Print Support App (PSA) 仮想プリンターで、Job UI ウィンドウが印刷を行ったアプリの背面に表示されてしまう","slug":"virtualprinter-z-order-issue","date":"2026-01-08T15:00:00.000Z","updated":"2026-02-05T09:21:50.218Z","comments":true,"path":"2026/01/09/virtualprinter-z-order-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2026/01/09/virtualprinter-z-order-issue/","excerpt":"この記事では Print Support App の仮想プリンターで発生する問題について説明します。","text":"この記事では Print Support App の仮想プリンターで発生する問題について説明します。 概要アプリから Print Support App (PSA) で作成された仮想プリンターに対して印刷を行った際、仮想プリンターの PrintWorkflowVirtualPrinterSession.VirtualPrinterDataAvailable で LaunchAndCompleteUIAsync を呼び出してプリント ワークフロー Job UI を表示した際に、表示された Job UI のウィンドウが、印刷を行ったアプリの背後に隠れてしまう現象が発生します。この現象は、印刷を行ったアプリが 32-bit アプリケーションだった場合に発生します。64-bit OS 上の 64-bit アプリの場合は、発生しません。 現象問題の現象が発生する手順は次の通りです。 32-bit アプリケーションを起動します。(例：%WINDIR%\\SysWOW64\\msinfo32.exe など) 仮想プリンターに対して印刷を行います。 仮想プリンターのワークフロー Job UI ウィンドウが開きます。 次の青く囲った部分のように、PSA のウィンドウが印刷を行ったアプリ ウィンドウの背後に隠れてしまうことがあります。 原因フォアグラウンド ウィンドウを設定できるプロセスは、システムによって制限されています。制限を解除するためには、AllowSetForegroundWindow 関数などを用いて事前に設定が必要となります。印刷を行うアプリと、ワークフロー Job UI を表示するプログラムは、別プロセスでありこれらの制限を解除する必要がありますが、現状では、特定の条件下においてこの制限を正しく解除できていないため、ワークフロー Job UI が前面に表示されない問題が発生しています。 回避方法この問題に対して PSA 側での実装では、有効な回避方法がありません。そのため、本現象が発生した場合は、アプリの背面に表示されたウィンドウをクリックして、前面に表示して操作を行ってください。あるいは、タスクバーでハイライトされているアイコンをクリックして、ワークフロー Job UI の操作を行ってください。 状況この現象についてはマイクロソフトの不具合として認識しており開発部門へ報告済みとなりますが、現時点では修正の予定が決まっておりません。 変更履歴2026/01/09 created by riwaida","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"printer","slug":"printer","permalink":"https://jpwdkblog.github.io/blog/tags/printer/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 3 - ドライバーロード時のデバッガー アタッチ)","slug":"umdf_remote_debug_part3","date":"2025-10-01T15:00:00.000Z","updated":"2026-02-05T09:21:50.210Z","comments":true,"path":"2025/10/02/umdf_remote_debug_part3/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/10/02/umdf_remote_debug_part3/","excerpt":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。","text":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。 事前準備以下のパート 1, 2 が完了していること。 Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 1 - ドライバーのビルドとインストール) Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 2 - デバッガーの接続とデバッグ) ドライバーの初期化からデバッグを開始するパート 1 と 2 では、既にロードされているドライバーのホスト プロセス (WUDFHost.exe) に対してデバッガーをアタッチしました。しかしこの方法では、ドライバーの初期化処理である DriverEntry や EvtDriverDeviceAdd コールバック ルーチン内の処理中にデバッガーをアタッチすることができず、デバッグを行うことができません。次の手順では、この問題を解決するための設定とリモート デバッグを開始する方法を説明します。 ターゲット PC 上で、レジストリ エディタ (regedit.exe) を起動します。起動後、次のレジストリを設定します。 レジストリ キー 値の型 値の名前 値 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WUDF\\DebugMode REG_DWORD DebugModeFlags 0x07 (16進) HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WUDF\\Services\\{ドライバー サービス名}\\Parameters\\Wdf REG_DWORD HostProcessDbgBreakOnDriverLoad 120 (秒) [DebugModeFlags(https://learn.microsoft.com/ja-jp/windows-hardware/drivers/wdf/registry-values-for-debugging-kmdf-drivers#debugmodeflags) はデバッグ モードを有効化し、デバイス プールの機能を無効化します。さらに再起動までのタイムアウトを無効化します。HostProcessDbgBreakOnDriverLoad は、デバッガーがアタッチされるまでの待機時間を秒単位で指定します。レジストリ キーにある ドライバー サービス名 は、INF ファイルの UmdfService ディレクティブに指定した serviceName です。&lt;Toaster UMDF ドライバーの例&gt;この例では wdfsimpleum が serviceName となります。1234;-------------- WDF specific section -------------[Toaster_Device.NT.Wdf]UmdfService=wdfsimpleum, Toaster_InstallUmdfServiceOrder=wdfsimpleum ターゲット PC 上でデバイス マネージャーを起動して、対象のデバイスを一度無効化し、ドライバーをアンロードされた状態にします。 開発環境の PC の Visual Studio で DriverEntry 関数と ToasterEvtDeviceAdd 関数にブレークポイントをセットしておきます。 開発環境の PC の Visual Studio で [デバッグ] &gt; [プロセスにアタッチ] を選択し (または Ctrl+Alt+P キーを押し)、**[プロセスにアタッチ]** ダイアログ ボックスを開きます。**[接続の種類]** を [リモート (Windows - 認証なし)] の設定が維持されていることを確認し、フィルターのボックスに WUDFHost.exe と入力します。 [!NOTE]上の画像のように、既に起動している WUDFHost.exe が表示される場合もありますが、これはデバッグ対象のドライバー用プロセスではないため、アタッチしないでください。次の手順でデバイスを有効化した時に、対象のプロセスが分からなくならないよう、起動済み WUDFHost.exe の PIDをメモしておくと、後の手順でプロセスを特定しやすくなります。 ターゲット PC に移動し、デバイス マネージャーでデバイスを有効化します。 開発環境の PC に戻り [プロセスにアタッチ] ダイアログ ボックスに参照すると、新たに WUDFHost.exe が増えていることが確認できるため、そのプロセスを選択して、**[アタッチする]** をクリックします。 DebugBreak のコードにヒットして、自動でデバッガーにブレークインします。F5 キーを押下して、そのまま実行を継続すると、手順 3 でドライバーの DriverEntry に設定しておいたブレークポイントにヒットして実行が停止します。そして、ステップ実行などによるデバッグ作業が行えるようになります。 まとめ手順にまとめると複雑な作業に見えますが、一連の操作に慣れてしまえば、簡単な操作でデバッグ作業を行うことができます。デバッガーを接続して、コードの実行状況を正しく把握することで、推測ベースのトライ &amp; エラーによる問題解決よりも、確実な調査を行えます。リモートによるデバッガー接続を行うメリットの一つとして、ターゲット PC 上でストレステストやランダムなテストを実行する長時間の試験においても、開発環境側には大きな影響を受けないという利点があります。さらに、Visual Studio を使ってプロセスにアタッチすることで、Visual Studio の 診断ツール も利用することができます。診断ツールでは、CPU、メモリの使用状況を視覚的に確認でき、メモリリークの調査も行うことができます。 変更履歴2025/10/01 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/tags/Debug/"},{"name":"UMDF","slug":"UMDF","permalink":"https://jpwdkblog.github.io/blog/tags/UMDF/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://jpwdkblog.github.io/blog/tags/Visual-Studio/"}],"keywords":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}]},{"title":"Windows 11 24H2 の WIA ドライバーのインストールにおいて ICM Profile が適用されない","slug":"w11_24h2_icmprofile_issue","date":"2025-10-01T15:00:00.000Z","updated":"2026-02-05T09:21:50.225Z","comments":true,"path":"2025/10/02/w11_24h2_icmprofile_issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/10/02/w11_24h2_icmprofile_issue/","excerpt":"この記事では、Windows 11 24H2 における WIA デバイス の INF ファイルに指定されているベンダー指定のカラー プロファイル (Image Color Matching Profile) が適用されない問題について説明します。","text":"この記事では、Windows 11 24H2 における WIA デバイス の INF ファイルに指定されているベンダー指定のカラー プロファイル (Image Color Matching Profile) が適用されない問題について説明します。 概要Windows 11 Version 24H2 (OS Build 26100) において、WIA ドライバー (スキャナー ドライバーなど) の INF ファイルで指定できる ICMProfiles の値が、ドライバーのインストールを行っても正しく適用されません。例えば、INF ファイルに次のような記述が行われている場合が該当します。 1ICMProfiles=&quot;My Scanner Color Space Profile.icm&quot; WIA ドライバーの INF ファイルの完全な例については、次のドキュメントをご参照ください。Hello World インストール ファイル - Windows drivers | Microsoft Learn また、WIA ドライバー固有の INF ファイル エントリについては、次のドキュメントをご参照ください。WIA デバイスの INF ファイル - Windows drivers | Microsoft Learn 現象この現象は Windows 11 24H2 で行われた変更が原因で発生しており、現状 100% の確率で発生します。なお、Windows 11 23H2 などの以前のバージョンでは発生しません。また、次のレジストリが書き込まれていないことで、事象の発生有無を確認することもできます。 レジストリ キー 値の型 値の名前 HKLM\\System\\CurrentControlSet\\Control\\Class\\{6bdd1fc6-810f-11d0-bec7-08002be2092f}\\{デバイスの番号}\\DeviceData REG_MULTI_SZ ICMProfile なお、値が設定されていない場合、標準の sRGB プロファイル (sRGB Color Space Profile.icm) が利用されます。そのため、INF ファイルに同プロファイルを指定しているドライバーでは、この問題によりデフォルトのプロファイルが利用されることとなるため、実質的な影響はありません。 回避方法現時点では、INF ファイルのみでこの問題を回避する方法はありません。しかし、ドライバーのインストール後、プログラム コードを用いて、API InstallColorProfile と WcsAssociateColorProfileWithDevice を呼び出すことで、指定した ICM Profile のインストールと WIA デバイスへの関連付けを行うことができます。これらの API を利用するコード サンプルは次のリンクよりご参照ください。 サンプル コード: ApplyIcmProfile.cpp [!NOTE]このサンプルコードはあくまで API の利用方法を説明するためのコードであり、動作を保証するものではないということをご了承ください。 上記各 API の詳細については次のドキュメントをご参照ください。InstallColorProfileW - Win32 apps | Microsoft LearnWcsAssociateColorProfileWithDevice - Win32 apps | Microsoft Learn 状況本問題は、Windows の不具合であると認識しており、現在修正に向けて作業中となります。明確な修正プログラムの提供時期については現時点では未定ですが、過去の経緯や現段階での作業状況から 2026 年 1 月ごろとなると予想しております。具体的な提供時期などアップデートがあり次第、こちらで状況を更新いたします。 関連情報：Windows クライアントの更新リリース サイクル | Microsoft Learn 変更履歴2025/10/02 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"Windows 11 24H2","slug":"Windows-11-24H2","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11-24H2/"},{"name":"bug","slug":"bug","permalink":"https://jpwdkblog.github.io/blog/tags/bug/"},{"name":"WIA","slug":"WIA","permalink":"https://jpwdkblog.github.io/blog/tags/WIA/"},{"name":"install","slug":"install","permalink":"https://jpwdkblog.github.io/blog/tags/install/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 2 - デバッガーの接続とデバッグ)","slug":"umdf_remote_debug_part2","date":"2025-09-30T15:00:00.000Z","updated":"2026-02-05T09:21:50.179Z","comments":true,"path":"2025/10/01/umdf_remote_debug_part2/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/10/01/umdf_remote_debug_part2/","excerpt":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。","text":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。 事前準備以下のパート 1 が完了していること。 Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 1 - ドライバーのビルドとインストール) デバッガーの接続次の手順を実施して、開発環境の PC から ターゲット PC 上のプロセスに対して、デバッガーをアタッチして、デバッグ可能な状態にします。 ターゲット PC 上にインストールした Remote Tools for Visual Studio の Remote Debugger を [管理者として実行] で起動します。初回起動の場合、ファイアウォールの設定が表示されますが、すべて既定の状態で起動します。 [ツール] メニューから [オプション] を選択して、認証の設定を行います。今回は簡略化のため認証なしの設定 (以下) で行います。 設定項目 設定値 TCP&#x2F;IP ポート番号 4026 認証モード 認証なし すべてのユーザーにデバッグを許可する チェックする アイドル タイムの最大値 (秒) 3600 ターゲット PC 上で [ターミナル (管理者)] を起動 (あるいはコマンド プロンプトを管理者として実行) して、次のコマンドを入力します。Visual Studio からデバッガーをアタッチするプロセス ID を確認します。 1tasklist /m wdfsimpleum.dll 開発環境の PC の Visual Studio で [デバッグ] &gt; [プロセスにアタッチ] を選択し (または Ctrl+Alt+P キーを押し)、**[プロセスにアタッチ]** ダイアログ ボックスを開きます。 [接続の種類] を [リモート (Windows - 認証なし)] に設定し、**[検索]** ボタンをクリックします。**[リモート接続]** ダイアログ ボックスを開きます。 手順 2 で設定したターゲット PC が自動で検出されるため [選択] ボタンをクリックして、ダイアログを閉じます。 [プロセスにアタッチ] ダイアログ ボックスに戻り、ターゲット PC 内のプロセス一覧が表示されるため、Ctrl+E キーを押してフィルターのボックスに手順 3 で確認した、デバッグ対象のプロセス ID を入力します。WUDFHost.exe を選択して、**[アタッチする]** をクリックします。 Visual Studio のメニューから [デバッグ] &gt; [ウィンドウ] &gt; [モジュール] の順にクリックして、UMDF ドライバーのシンボルがロードされていることを確認します。 以上でデバッグできる状態になりました。次のステップに進み、実際のデバッグ操作を行います。 ソースコード レベル デバッグの実施現在、ドライバー wdfsimpleum.dll はロードされているだけの状況であり、初期化処理以外は、この段階では特に処理を実行していません。そのためドライバーを呼び出すアプリケーションを実行して、ドライバー コードを実行します。次の手順で、ドライバー コードが実行されたタイミングをデバッガーで捕捉します。 ドライバーに対して ReadFile と DeviceIoControl を呼び出すアプリケーション toast.exe がサンプルには用意されているため、そのアプリケーションを利用します。 以下はドライバーの ReadFile を呼び出しているコード部分の抜粋です。 1234567891011121314151617181920212223//// Read/Write to the toaster device.//printf(&quot;\\nPress &#x27;q&#x27; to exit, any other key to read...\\n&quot;);fflush(stdin);ch = _getche();while(tolower(ch) != &#x27;q&#x27; )&#123; if(!ReadFile(file, buffer, sizeof(buffer), &amp;bytes, NULL)) &#123; printf(&quot;Error in ReadFile: %x&quot;, GetLastError()); break; &#125; printf(&quot;Read Successful\\n&quot;); ch = _getche();&#125;free (deviceInterfaceDetailData);CloseHandle(file);return 0; サンプルをビルドすると以下のパスに toast.exe が生成されるため、このファイルをターゲット PC 側の任意のフォルダー (C:\\temp など) へコピーします。 12345678umdf2└─exe ├─enum ├─notify └─toast └─x64 (or arm64) └─Debug (or Release) └─ toast.exe ターゲット PC 上の管理者権限で実行されているコマンドプロンプトにて toast.exe を実行します。次のような出力が得られればデバイスのオープンができています。 1234567891011121314c:\\temp&gt;toast.exeInstance ID : ROOT\\UNKNOWN\\0000Description : Sample UMDF Toaster Driver - simpleFriendlyName:List of Toaster Device Interfaces---------------------------------1) \\\\?\\root#unknown#0000#&#123;781ef630-72b2-11d2-b852-00c04fad5171&#125;Opening the last interface:\\\\?\\root#unknown#0000#&#123;781ef630-72b2-11d2-b852-00c04fad5171&#125;Press &#x27;q&#x27; to exit, any other key to read... [!NOTE]toast.exe の実行時 VCRUNTRIME140.dll が見つからないといったエラーが出る場合は、プロジェクトのプロパティでランタイム ライブラリの設定を /MT あるいは /MTd にしてビルドすることで回避できます。関連ドキュメント: &#x2F;MD、&#x2F;MT、&#x2F;LD (ランタイム ライブラリを使用) 開発環境の Visual Studio で Func\\Simple\\Source Files\\toast.c を開き、ToasterEvtIoRead 関数の先頭にブレークポイントをセットします。 ターゲット PC の toast.exe を実行したコンソール画面に戻り、’q’ キー以外の任意のキーを押下します。すると、開発環境の Visual Studio 側で ToasterEvtIoRead 関数でブレークインして、実行が停止します。そして、デバッグしたいコードまで F10 キーなどを押下することでステップ実行することができます。 まとめ以上、パート 2 ではリモートデバッガーを接続して、任意のタイミングで実行されるコードのデバッグを行えることまでを確認しました。 次回の記事では、任意のタイミングではなく UMDF ドライバーの DriverEntry や EvtDriverDeviceAdd ルーチンといった初期化処理におけるリモート デバッグについて説明します。 変更履歴2025/10/01 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/tags/Debug/"},{"name":"UMDF","slug":"UMDF","permalink":"https://jpwdkblog.github.io/blog/tags/UMDF/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://jpwdkblog.github.io/blog/tags/Visual-Studio/"}],"keywords":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}]},{"title":"Visual Studio で User Mode Driver をリモート デバッグする方法 (パート 1 - ドライバーのビルドとインストール)","slug":"umdf_remote_debug_part1","date":"2025-09-29T15:00:00.000Z","updated":"2026-02-05T09:21:50.148Z","comments":true,"path":"2025/09/30/umdf_remote_debug_part1/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/09/30/umdf_remote_debug_part1/","excerpt":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。","text":"この記事では、Visual Studio と Remote Tools for Visual Studio を使用した User Mode Driver のリモート デバッグ方法について説明します。 事前準備 ドライバーをビルド・デバッグを行う開発環境の PC とドライバーを実行しテストを行うターゲット PC をそれぞれ 1 台ずつ計 2 台の PC あるいは仮想マシンを用意します。 開発環境には Visual Studio、Windows Driver Kit (WDK) をインストールし、Windows Driver Kit サンプルを事前にダウンロードしておきます。WDK のインストールと、サンプルのダウンロードは次のリンクをご参照ください。 Download the Windows Driver Kit (WDK) GitHub - Windows-driver-samples ターゲット PC に Remote Tools for Visual Studio をインストールします。 Download and Install the remote tools ターゲット PC でテスト署名を有効化します。必要に応じて事前にセキュア ブートを BIOS で無効化します。テスト署名の有効化は、ドキュメント “テスト署名されたドライバーの読み込みを有効にする“ にあるように、管理者権限で起動したコマンド プロンプトで bcdedit.exe を次のように呼び出します。1Bcdedit.exe -set TESTSIGNING ON User Mode Driver について事前準備が完了したらサンプル ドライバーのビルドを行います。この記事では User Mode Driver を対象としておりますが、User Mode Driver と言っても様々な種類があります。例えば次のような種類のドライバーがあります。 GPS &#x2F; GNSS (Global Navigation Satellite System GNSS) driver GPIO peripheral device driver Indirect display driver UMDF NetAdapterCx client driver POS barcode scanner driver Printer driver ※ WIA driver ※ ※ Printer および WIA ドライバーは一般的な User Mode Driver Framework (UMDF) のドライバーとは異なるため、この記事のシリーズで紹介している内容の一部は適用されません。 サンプル ドライバーのビルドこの記事では Generic なサンプルとして提供されている Toaster サンプルを使用します。Toaster サンプルは KMDF 版と UMDF 版の2種類がありますが UMDF 版は Windows-driver-samples&#x2F;general&#x2F;toaster&#x2F;umdf2 にあります。 開発環境 PC の Visual Studio で Windows-driver-samples\\general\\toaster\\umdf2\\umdf2toaster.sln を開きます [Solution Explorer] を見ると、そのソリューション内には Exe, Filter, Func, Package というプロジェクトがありますが、ひとまず Solution 部分をクリックします。 続いて、ビルド対象を選びます。 [ビルド] メニューから [ソリューションのリビルド] を選びビルドします。 ビルドが正常に終わると、その結果として x64 Debug の場合、次のような出力ファイルが得られます。12345678910umdf2└─x64 └─Debug ├─package.cer └─package ├─filterum.dll ├─filterum.inf ├─wdfsimpleum.dll ├─wdfsimpleum.inf └─wudf.cat ドライバーのインストールドライバーのインストールにはいくつか方法がありますが、今回はドライバー パッケージを手動でターゲット PC にコピーして、デバイス マネージャーを使ってインストールします。 前の手順の 5 の Debug フォルダーをターゲット PC の任意のフォルダーにコピーします。 ターゲット PC 上でコピー先フォルダー内にある package.cer を右クリックして [証明書のインストール] をクリックします。 証明書のインポート ウィザードで次の設定で選び、完了 をクリックして証明書をインポートします。 設定項目 設定値 保存場所 ローカル コンピューター 証明書をすべて次のストアに配置する チェックする 証明書ストア 信頼されたルート証明機関 物理ストアを表示する チェックしない スタート メニューを右クリックしてデバイス マネージャーを起動します。 [操作] メニューをクリックして、**[レガシ ハードウェアの追加]** をクリックします。 [ハードウェアの追加] ウィザードで、次の設定を行い、ドライバーとデバイスのインストールを行います。6-1. インストール方法の選択で [一覧から選択したハードウェアをインストールする (詳細)] を選び次へ。6-2. [共通ハードウェアの種類] で [すべてのデバイスを表示] を選び次へ。6-3. [ディスクを使用] をクリックして、ドライバー パッケージをコピーしたフォルダーに移動して wdfsimpleum.inf を選び [開く] をクリックします。6-4. Sample UMDF Toaster Driver - simple を選び [次へ] をクリックし、残りのウィザードを進め完了します。 デバイス マネージャーに次のように表示されインストールが完了していることが分かります。 また、スタート メニューから管理者権限でターミナルを起動し、次のコマンドを入力すると UMDF ドライバーがどのプロセスにロードされているのかを確認できます。 12345PS C:\\&gt; tasklist /m wdfsimpleum.dllImage Name PID Modules========================= ======== ============================================WUDFHost.exe 12412 wdfsimpleum.dll ドライバーのインストール ログを確認する場合は C:\\Windows\\INF\\setupapi.dev.log を参照します。ログの見方などについては SetupAPI テキスト ログ をご参照下さい。以下は実際に Toaster UMDF ドライバーをインストールした時のログの抜粋です。 &gt;&gt;&gt; [Device Install (DiInstallDevice) - ROOT\\UNKNOWN\\0000] &gt;&gt;&gt; Section start 2025/09/30 17:19:51.937 cmd: &quot;C:\\WINDOWS\\system32\\mmc.exe&quot; C:\\WINDOWS\\system32\\devmgmt.msc ndv: Flags: 0x00000002 dvi: Class GUID of device changed to: &#123;b85b7c50-6a01-11d2-b841-00c04fad5171&#125;. sto: &#123;Setup Import Driver Package: c:\\temp\\debug\\package\\wdfsimpleum.inf&#125; 17:19:51.939 inf: Provider: TODO-Set-Provider inf: Class GUID: &#123;B85B7C50-6A01-11d2-B841-00C04FAD5171&#125; inf: Driver Version: 09/30/2025,16.8.45.553 inf: Catalog File: wudf.cat sto: &#123;Copy Driver Package: c:\\temp\\debug\\package\\wdfsimpleum.inf&#125; 17:19:51.943 sto: Driver Package = c:\\temp\\debug\\package\\wdfsimpleum.inf sto: Flags = 0x00000007 sto: Destination = C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125; sto: Copying driver package files to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;&#39;. flq: &#123;FILE_QUEUE_COMMIT&#125; 17:19:51.945 flq: Copying &#39;c:\\temp\\debug\\package\\wdfsimpleum.dll&#39; to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wdfsimpleum.dll&#39;. flq: Copying &#39;c:\\temp\\debug\\package\\wdfsimpleum.inf&#39; to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wdfsimpleum.inf&#39;. flq: Copying &#39;c:\\temp\\debug\\package\\wudf.cat&#39; to &#39;C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wudf.cat&#39;. flq: &#123;FILE_QUEUE_COMMIT - exit(0x00000000)&#125; 17:19:51.953 sto: &#123;Copy Driver Package: exit(0x00000000)&#125; 17:19:51.953 ump: Import flags: 0x00000000 pol: &#123;Driver package policy check&#125; 17:19:52.002 pol: &#123;Driver package policy check - exit(0x00000000)&#125; 17:19:52.002 sto: &#123;Stage Driver Package: C:\\Users\\LOCALA~1\\AppData\\Local\\Temp\\&#123;80ada83c-a1a3-e241-a557-f69a205c8309&#125;\\wdfsimpleum.inf&#125; 17:19:52.002 inf: Provider = TODO-Set-Provider inf: Class GUID = &#123;b85b7c50-6a01-11d2-b841-00c04fad5171&#125; inf: Driver Version = 09/30/2025,16.8.45.553 inf: Catalog File = wudf.cat inf: Version Flags = 0x00000013 (以下、省略) まとめ以上でドライバーのインストールまで完了です。今回ドライバーのインストールは、デバイス マネージャーから手動でインスールしましたが、実際のドライバーはデバイスの接続に応じたプラグアンドプレイによるインストールになることが想定されます。なお、今回のインストールでは ROOT\\Unknown\\0000 というデバイス インスタンスを作成して、ドライバーを割り当てているため、物理的なデバイスは存在していません。USB などのプラグアンドプレイのシナリオでは、バス ドライバーが USB\\VID_xxxx&amp;PID_yyyy\\* のようなデバイス インスタンスを生成し、ドライバーがインストールされます。 次回の記事では、実際にリモートでデバッガーを接続してアプリケーションからドライバーを呼び出した時の様子を開発環境上の PC で動作する Visual Studio でデバッグする作業を行います。 変更履歴2025/09/30 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。 ※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/tags/Debug/"},{"name":"UMDF","slug":"UMDF","permalink":"https://jpwdkblog.github.io/blog/tags/UMDF/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://jpwdkblog.github.io/blog/tags/Visual-Studio/"}],"keywords":[{"name":"Debug","slug":"Debug","permalink":"https://jpwdkblog.github.io/blog/categories/Debug/"}]},{"title":"HLK のテストが失敗した場合のトラブルシューティング手順","slug":"howto-troubleshoot-hlk-test-fail","date":"2025-07-09T15:00:00.000Z","updated":"2026-02-05T09:21:50.017Z","comments":true,"path":"2025/07/10/howto-troubleshoot-hlk-test-fail/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/07/10/howto-troubleshoot-hlk-test-fail/","excerpt":"この記事では、Hardware Lab Kit (HLK) のテストで FAIL が発生した時の一般的なトラブルシューティング方法をご案内いたします。","text":"この記事では、Hardware Lab Kit (HLK) のテストで FAIL が発生した時の一般的なトラブルシューティング方法をご案内いたします。 1. HLK で実施すべきテスト項目であったかどうかを確認するまず、前提として実施されたテスト項目が認定を受けるうえで必須のテスト項目であったかどうかをチェックします。HLK のテストは、Windows Hardware Compatibility Program Specifications and Policies で定義されている要件に沿ったドライバーあるいはハードウェアであるかどうかをチェックする目的があります。つまり、対象のドライバーおよびデバイスに対するポリシー要件を定義されていない内容に対するテストは、そもそも実施する必要がありません。実施すべきテストのみが正しく選択されているかどうかは、”プレイリスト” が適用されているかどうかによって変わります。 この “プレイリスト” については、次のドキュメントに適用方法が記載されていますので、こちらをご覧ください。手順 6:テストの選択と実行 - プレイリスト “プレイリスト” ファイルは、次のドキュメントからダウンロードできます。Windows ハードウェア互換性プログラム - プレイリスト 2. HLK FiltersHLK では、テスト ツールそのものの問題や OS 側の問題、要件定義の問題など、お客様デバイスやドライバー以外が原因でテストが Fail となる場合があります。このような場合、その Fail についてはテスト結果を免除するためのフィルターがあります。フィルターのインストール手順とダウンロードは こちら からご確認いただけます。フィルターは機械的に毎日更新処理が実行されており、アップデートがある場合はフィルター ファイルも更新されます。そのため、テストを実施する場合は、まずフィルターのダウンロードと更新作業を実施いただくことをお勧めします。 その他フィルターの有無を DTM Filtes にて確認します。HLK Filters には、自動で適用されるもの以外にマニュアルで適用されるものもあります (通称、Manual Errata)。これは、マイクロソフトのサポート エンジニアからの指示のもとで適用されるフィルターとなります。基本的には、弊社までお問い合わせいただくことが前提となります。前述のサイトに関連しそうな内容や類似のものが見つかった場合は、お気兼ねなく 弊社サポート までお問い合わせください。お問い合わせいただく際の製品カテゴリは次の通りです。 3. エラー メッセージの確認エラーログは通常、ログファイル（.wtl）に記録されており、[Result] タブでテスト結果をダブルクリックすることで開くことができます。どのテストで失敗しているのかを確認後、対応するテスト ドキュメントを確認します。テスト ドキュメントには、事前に設定すべき内容(Prerequisites) や、事前に設定すべきパラメータ (Parameters) などが記載されています。テストによっては、手動操作が求められているものもあるため、操作が不足していないかなどもご確認ください。 例：Audio Codec - USB Audio Logo Test (Manual) - Certification - Desktop 4. トラブル シューティング作業失敗したテストは、そのテスト ツールだけをエクスポートして、HLK コントローラなしでスタンドアロンで個別実行することが可能です。この操作によって、デバッグ作業やログ採取など必要なアクションを行いやすくできる場合があります。次のドキュメントで失敗したテストジョブのエクスポート手順および実行手順が記載されていますので、ご確認ください。失敗した HLK ジョブのエクスポート また、すべてのドライバーは DF - InfVerif INF Verification と呼ばれるテストが実行されます。このテストは、ドライバーをインストールするための INF ファイルの記述などの検証を行うテストとなります。基本的に OS のバージョンが新しいものになるにつれて、INF の記述に関する要件が増え、より厳格になっている傾向があります。お客様のドライバーが要件に沿っているかどうかをチェックするためには、Windows Hardware Compatibility Program Specifications and Policies をご確認いただく必要がありますが、最新の Windows Driver Kit に含まれている InfVerif ツールを用いてツールでチェックすることもできます。要件に沿っているかどうかは &#x2F;h オプションを指定してツールを実行します。 なお、HLK とは直接関係ありませんが、HLK のテストを行わずにドライバーへの署名だけを Hardware DevCenter に依頼する場合も、この InfVerif ツールの検証だけは行われます。そのため、ドライバーを作成した場合は、必ず InfVerif &#x2F;h での検証を行っていただくことをお勧めいたします。 関連情報Windows HLK 環境のトラブルシューティングWindows HLK テストのエラーのトラブルシューティングINF の検証エラーと警告 変更履歴2025&#x2F;07&#x2F;10 created by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"hlk","slug":"hlk","permalink":"https://jpwdkblog.github.io/blog/categories/hlk/"}],"tags":[{"name":"test","slug":"test","permalink":"https://jpwdkblog.github.io/blog/tags/test/"}],"keywords":[{"name":"hlk","slug":"hlk","permalink":"https://jpwdkblog.github.io/blog/categories/hlk/"}]},{"title":"Windows 11 24H2 で印刷を行うとメモリリークが発生することがある","slug":"printing-causes-memory-leak","date":"2025-07-09T08:00:00.000Z","updated":"2026-02-05T09:21:50.110Z","comments":true,"path":"2025/07/09/printing-causes-memory-leak/","link":"","permalink":"https://jpwdkblog.github.io/blog/2025/07/09/printing-causes-memory-leak/","excerpt":"この記事では、Windows 11 24H2 および Windows Server 2025 上での印刷処理において発生するメモリリークについて説明します。","text":"この記事では、Windows 11 24H2 および Windows Server 2025 上での印刷処理において発生するメモリリークについて説明します。 概要Windows Version 24H2 (OS Build 26100) において、v3 プリンター ドライバーを使ってドキュメントを印刷すると、スプーラー サービス (spoolsv.exe) でメモリリークが発生することを確認しております。 この現象は、v3 プリンター ドライバーの DrvEnableSurface コールバック関数以外のコールバック関数で EngCreateBitmap 関数 を呼び出している場合に発生します。例えば、DrvBitBlt や DrvStretchBlt などのようなビット ブロック転送機能を実装するドライバーのコールバック関数で EngCreateBitmap &#x2F; EngDeleteSurface 関数 の呼び出しで発生します。印刷するドキュメントの内容によって、ドライバーで実行されるコードパスが変わるため、事象の発生は 100 %ではありません。 現象印刷を繰り返すと、spoolsv.exe のメモリ使用量 (タスク マネージャーのワーキング セットやコミット サイズ) の値が徐々に増加します。 また、実際にメモリの解放が失敗した時には、EngDeleteSurface 関数の呼び出しが失敗 (FALSE を返す) ことが確認されています。ドライバー側の処理で、EngDeleteSurface 関数の戻り値を確認していただくことでも、事象の発生有無を確認することができます。 回避方法現状、この問題を確実に回避する方法はありませんが、プリンタードライバーの分離機能を有効化することで、常時実行されているスプーラー サービスで発生するメモリリークの問題を別のプロセス (PrintIsolationHost.exe) に分離することができます。この PrintIsolationHost.exe は常駐で実行されるものではなく、一定時間使用されなくなるとプログラムが自動で終了します。確保されていたメモリはプログラム (.exe) が終了すると、強制的に解放されるため、結果的にメモリリークしていたメモリも解放さることになります。プリンタードライバーの分離機能を有効化するためには、次の手順を実行します。 [印刷の管理] を起動します。 左側のペインで [プリント サーバー] - [&lt;PC 名&gt; (ローカル)] - [ドライバー] の順に展開します。対象のプリンタードライバーを右クリックして [ドライバーの分離の設定] - [分離] の順にクリックして機能を有効化します。 状況本問題は、Windows における GDI の問題であると認識しており、現在修正作業行っております。現時点で、Windows 11 24H2 に対する修正は 2025 年 9 月の提供を目標に作業中です。Windows Server OS については、クライアント OS の提供後、約 4 カ月後となるため 2026 年 1 月あるいは 2 月に提供となる見込みです。なお、修正プログラムの提供は、他の修正プログラムの影響なども受けるため、状況によって予定は変更となる場合がございます。今後の状況については、アップデートがあり次第こちらで更新します。 2025 年 7 月 28 日更新本問題の修正が含まれる累積更新プログラム全体のテスト パスが開始中しています。現段階では作業に遅延は確認されていません。次回は 8 月の第 1 週目を目途に更新いたします。 2025 年 8 月 12 日更新予定通りテストは大きな問題もなく完了しました。現段階では作業に遅延は確認されていません。次回は 8 月 25 日の週に更新を予定しています。 2025 年 8 月 29 日更新8 月の オプションのセキュリティ以外のプレビュー リリースのサインオフの作業に若干の遅れが生じていましたが、近日中にリリース予定です。次回は前述のプレビュー リリースが公開になりましたら更新いたします。関連情報：更新プログラムのリリース サイクル 2025 年 9 月 02 日更新8 月の オプションのセキュリティ以外のプレビュー リリースが以下にて公開されました。本問題の修正コードが有効化される次回オプションのセキュリティ以外のプレビュー リリースは、9 月の第 4 週の提供予定となっております。現時点では 9 月 24 日にスケジュールされていますが状況によって変わる場合がございます。9 月の第 3 週に改めて更新いたします。関連情報：2025 年 8 月 29 日 — KB5064081 (OS ビルド 26100.5074) プレビュー 2025 年 9 月 30 日更新9 月の オプションのセキュリティ以外のプレビュー リリースが以下にて公開されました。KB5065789 をインストールすることで、本メモリリークの問題に対する修正プログラムが適用されます。関連情報：2025 年 9 月 29 日 — KB5065789 (OS ビルド 26100.6725) プレビュー関連情報：Microsoft Update Catalog 変更履歴2025/07/10 created by riwaida2025/07/28 updated by riwaida2025/08/12 updated by riwaida2025/08/29 updated by riwaida2025/09/02 updated by riwaida2025/09/30 updated by riwaida ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"print","slug":"print","permalink":"https://jpwdkblog.github.io/blog/tags/print/"},{"name":"Windows 11 24H2","slug":"Windows-11-24H2","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11-24H2/"},{"name":"Windows Server 2025","slug":"Windows-Server-2025","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-Server-2025/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Print Support App (PSA) にて用紙の設定が既定の値にならない","slug":"psa-default-value-issue","date":"2024-08-22T15:00:00.000Z","updated":"2026-02-05T09:21:50.115Z","comments":true,"path":"2024/08/23/psa-default-value-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2024/08/23/psa-default-value-issue/","excerpt":"この記事では Print Support App で発生する問題について説明します。","text":"この記事では Print Support App で発生する問題について説明します。 概要PSA の PrintSupportExtensionSession.PrintDeviceCapabilitiesChanged イベント ハンドラーで PrintDeviceCapabilities に追加の PageMediaType オプションを追加すると、既定のオプションが選ばれない現象が発生します。 現象例えば PageMediaType Feature で ContosoMediaType というのを追加し、次のような PrintTicket を構成した場合 default=&quot;true&quot; が指定されている AutoSelect がオプションとして既定の設定となることが期待されます。 1234567&lt;!-- media-type-supported --&gt;&lt;psk:PageMediaType psf2:psftype=&quot;Feature&quot;&gt; &lt;psk:AutoSelect psf2:psftype=&quot;Option&quot; psf2:default=&quot;true&quot;/&gt; &lt;psk:PhotographicGlossy psf2:psftype=&quot;Option&quot; psf2:default=&quot;false&quot;/&gt; &lt;psk:Photographic psf2:psftype=&quot;Option&quot; psf2:default=&quot;false&quot;/&gt; &lt;contoso:ContosoMediaType psf2:psftype=&quot;Option&quot; psf2:default=&quot;false&quot;/&gt;&lt;/psk:PageMediaType&gt; しかし、実際には別のオプションが既定の PrintTicket として構成される現象が発生します。本現象は PSA の印刷設定画面の最初の表示時に発生し、一度、設定が保存されると問題は発生いたしません。 回避方法本現象を回避するためには、PSA の PrintSupportExtensionSession.PrintDeviceCapabilitiesChanged イベント ハンドラーにて、既定のオプションとなるオプションを PSA 自身で保存し、ユーザー既定の PrintTicket を印刷設定ダイアログを表示するタイミングで、保存した値をリストアすることで回避可能出来ます。 １．まず、PSA の BackgroundTask の LocalStorageUtil クラスに次のようなコードを追加します。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 // 既に既定のオプションを PrintTicket へ設定したかどうかを確認するためのメソッド public static bool IsAlreadyLoadedDefaultValue() &#123; try &#123; return (bool)ApplicationData.Current.LocalSettings.Values[&quot;IsLoadedDefaultValue&quot;]; &#125; catch (NullReferenceException e) &#123; return false; &#125; &#125; // 既定のオプションを PrintTicket へ適用したことを示すためのメソッド public static void LoadedDefaultValue(bool _bLoaded) &#123; ApplicationData.Current.LocalSettings.Values[&quot;IsLoadedDefaultValue&quot;] = _bLoaded; &#125; // 指定 Feature のデフォルト オプションの値を保存します public static void SetPdcDefaultValue(string _Feature, string _DefaultValue) &#123; System.Diagnostics.Debug.WriteLine(&quot;SetPdcDefaultValue: Feature=&quot; + _Feature + &quot;, Default=&quot; + _DefaultValue); ApplicationData.Current.LocalSettings.Values[_Feature] = _DefaultValue; &#125; // 指定 Feature のデフォルト オプションの値を返します public static string GetPdcDefaultValue(string _Feature) &#123; try &#123; return (string)ApplicationData.Current.LocalSettings.Values[_Feature]; &#125; catch (NullReferenceException e) &#123; System.Diagnostics.Debug.WriteLine(e.Message); return null; &#125; &#125;``` ２．`PrintSupportExtensionSession.PrintDeviceCapabilitiesChanged` イベント ハンドラーに、手順１で追加した `SaveDefaultValues()` を呼び出して、Print Device Capabilities に設定されている既定値を保存します。```C# private void OnSessionPrintDeviceCapabilitiesChanged(PrintSupportExtensionSession sender, PrintSupportPrintDeviceCapabilitiesChangedEventArgs args) &#123; var pdc = args.GetCurrentPrintDeviceCapabilities(); // Add the custom namesapce uri to the XML document. pdc.DocumentElement.SetAttribute(&quot;xmlns:contoso&quot;, &quot;http://schemas.contoso.com/keywords&quot;); // Add the custom media type. AddCustomMediaType(ref pdc, &quot;http://schemas.contoso.com/keywords&quot;, &quot;contoso:ContosoMediaType&quot;); // PDC のデフォルト値を保存するメソッドを呼び出します SaveDefaultValues(ref pdc); args.UpdatePrintDeviceCapabilities(pdc); args.SetPrintDeviceCapabilitiesUpdatePolicy( PrintSupportPrintDeviceCapabilitiesUpdatePolicy.CreatePeriodicRefresh(System.TimeSpan.FromMinutes(1))); args.GetDeferral().Complete(); &#125; ３．手順１と２で LocalStorageUtil に保存したオプションの既定値をコンボボックスの初期化処理などで利用し、コンボボックス アイテムの初期に設定します。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private ComboBox CreatePrintTicketFeatureComboBox(PrintTicketFeature feature, bool useDefaultEventHandler = true)&#123; if (feature == null) &#123; return null; &#125; var comboBox = new ComboBox &#123; // Header is displayed in the UI, ontop of the ComboBox. Header = feature.DisplayName &#125;; // Construct a new List since IReadOnlyList does not support the &#x27;IndexOf&#x27; method. var options = new ObservableCollection&lt;PrintTicketOption&gt;(feature.Options); // Provide the combo box with a list of options to select from. comboBox.ItemsSource = options; // Set the selected option to the option set in the print ticket. PrintTicketOption selectedOption; // PDC の既定値を LocalStorageUtil から1回だけ読み込む string defaultOption = LocalStorageUtil.GetPdcDefaultValue(feature.Name); if (!LocalStorageUtil.IsAlreadyLoadedDefaultValue() &amp;&amp; defaultOption != null) &#123; selectedOption = options[0]; foreach (var option in options) &#123; if (option.Name == defaultOption) &#123; // デフォルト値 selectedOption = option; break; &#125; &#125; &#125; else &#123; var featureOption = feature.GetSelectedOption(); try &#123; selectedOption = options.Single((option) =&gt; ( option.Name == featureOption.Name &amp;&amp; option.XmlNamespace == featureOption.XmlNamespace)); &#125; // Catch exceptions, because there can be multiple features with the &quot;None&quot; feature name. // We need to handle those features seperately. catch (System.SystemException exception) &#123; var nameAttribute = featureOption.XmlNode.Attributes.GetNamedItem(&quot;name&quot;); var attribute = featureOption.XmlNode.OwnerDocument.CreateAttribute(&quot;name&quot;); selectedOption = options.Single((option) =&gt; ( option.DisplayName == featureOption.DisplayName &amp;&amp; option.Name == featureOption.Name &amp;&amp; option.XmlNamespace == featureOption.XmlNamespace)); &#125; &#125; comboBox.SelectedIndex = options.IndexOf(selectedOption); // LocalStorageUtil からの読み込みが完了したことをセットします LocalStorageUtil.LoadedDefaultValue(true); 関連ドキュメントPrintSupportExtensionSession.PrintDeviceCapabilitiesChanged イベント 変更履歴2024/08/07 created by riwaida2024/08/24 modified by riwaida : 回避方法の追加2025/07/10 modified by riwaida : 変更履歴の記載","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"printer","slug":"printer","permalink":"https://jpwdkblog.github.io/blog/tags/printer/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Print Support App (PSA) の初回起動時、[設定] ウィンドウの背面に表示されてしまう","slug":"psa-z-order-issue","date":"2024-08-14T15:00:00.000Z","updated":"2026-02-05T09:21:50.121Z","comments":true,"path":"2024/08/15/psa-z-order-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2024/08/15/psa-z-order-issue/","excerpt":"この記事では Print Support App で発生する問題について説明します。","text":"この記事では Print Support App で発生する問題について説明します。 概要Print Support App (PSA) がインストールされた直後などにおいて、[設定] から起動時ウィンドウが設定画面の背後に隠れてしまう事象が発生します。PSA が起動する際、つぎのダイアログが表示されるケースで事象が発生します。 現象問題の事象が発生する手順は次の通りです。 スタート メニューから [設定] をクリックします。 [Bluetooth とデバイス] - [プリンターとスキャナー] の順にクリックします。 表示されたプリンターの一覧から PSA を起動するプリンターをクリックします。 [印刷設定] をクリックします。 次の青く囲った部分のように、PSA のウィンドウが設定画面の背後に隠れてしまうことがあります。 状況この現象については開発部門にて今後の対応を (次期メジャー OS アップデートでの対応について) 検討中となります。 2026 年 1 月 9 日更新Windows 11 25H2 ではこの問題の解消が確認されております。 変更履歴2024/08/15 created by riwaida2025/07/10 modified by riwaida : 状況の更新2026/01/09 modified by riwaida : 状況の更新","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"printer","slug":"printer","permalink":"https://jpwdkblog.github.io/blog/tags/printer/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"CPrintDialog を利用したアプリケーションから印刷できない","slug":"printer-CPrintDialog-issue","date":"2023-06-04T15:00:00.000Z","updated":"2026-02-05T09:21:50.061Z","comments":true,"path":"2023/06/05/printer-CPrintDialog-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2023/06/05/printer-CPrintDialog-issue/","excerpt":"この記事は、CPrintDialog を利用したアプリケーションから印刷した際に発生する問題について説明します。","text":"この記事は、CPrintDialog を利用したアプリケーションから印刷した際に発生する問題について説明します。 現象MFC の CPringDialog クラスを利用して [印刷] ダイアログから印刷を行った場合、正常に印刷が行われない場合があります。この現象は CPrintDialog::CPrintDialog() の第一引数 bPrintSetupOnly に TRUE、第二引数 dwFlags に PD_USEDEVMODECOPIES を指定している、または第二引数に何も設定していない場合に発生します。(第二引数 dwFlags に何も設定しない場合は、既定で PD_USEDEVMODECOPIES が設定されます。) なお、この現象が発生するとき、プリンター ドライバー側の視点では DrvStartDoc 関数が呼ばれません。 原因CPrintDialog::CPrintDialog() の第一引数 bPrintSetupOnly に TRUE、第二引数 dwFlags に PD_USEDEVMODECOPIES が指定された状況では、PrintDialog::m_pd構造体の nCopies メンバーが既定で 0 となります。この値は、印刷する部数を示しており、最終的に DEVMODE 構造体の dmCopies メンバーに設定されて GDI およびプリンタードライバーで利用されます。GDI は DEVMODE.dmCopies が 0 の場合、印刷する部数は無いものと判断して印刷を行いません。その際、GDI はプリンター ドライバーの DrvStartDoc 関数を呼び出しません。 回避方法CPrintDialog::CPrintDialog() の実行後に CPrintDialog::m_pd構造体の nCopies メンバーに 1 を設定します。 以下は回避方法としてのサンプルコード例となります。 CPrintDialog::CPrintDialog(TRUE) で dlg オブジェクトを構築した後に、m_pd構造体の nCopies に 1 を設定して、StartDoc 関数を実行します。 1234567891011121314151617181920212223242526272829303132HDC printHDC;CString strMsg;CPrintDialog dlg(TRUE);dlg.m_pd.nCopies = 1; if (dlg.DoModal() == IDOK)&#123; // DEVMODEの取得 DEVMODE* devmode = dlg.GetDevMode(); //印刷用HDCの取得 printHDC = CreateDC(NULL, dlg.GetDeviceName(), NULL, devmode); if (NULL == printHDC) &#123; strMsg.Format(_T(&quot;CreateDC is NULL&quot;)); MessageBox(strMsg); return; &#125; CDC PrinterDC; PrinterDC.Attach(printHDC); CString docname; docname.Format(_T(&quot;PrintTest&quot;)); DOCINFO docinfo = &#123; 0 &#125;; //DOCINFOを用意 docinfo.cbSize = sizeof(docinfo); docinfo.lpszDocName = docname; PrinterDC.StartDoc(&amp;docinfo); 参考情報CPrintDialog クラスDEVMODEA 構造体 (wingdi.h)PRINTDLGA structure (commdlg.h) 変更履歴2023&#x2F;06&#x2F;05 created by mitsuchi ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"CPrintDialog","slug":"CPrintDialog","permalink":"https://jpwdkblog.github.io/blog/tags/CPrintDialog/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"プリンタ― ドライバ―のアップデートを行った際に DEVMODE 情報が更新されない","slug":"printer-devmode-issue","date":"2022-09-19T15:00:00.000Z","updated":"2026-02-05T09:21:50.071Z","comments":true,"path":"2022/09/20/printer-devmode-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2022/09/20/printer-devmode-issue/","excerpt":"この記事は、プリンタードライバーのアップデートを行った際に発生する問題について説明します。","text":"この記事は、プリンタードライバーのアップデートを行った際に発生する問題について説明します。 前提となるシナリオプリンタードライバーのアップデート時にプライベート部分の DEVMODE サイズや構造体をプリンタードライバーが更新している場合になります。 発生する問題プリンタードライバーのアップデート時、更新されるドライバーでは、プライベート部分の DEVMODE サイズや構造体を更新している場合があります。このようなシナリオでは、プリンタードライバーが依頼した新しいバージョンの DEVMODE の形式に合わせて、各種 DEVMODE の値を OS が レジストリへ保存・更新します。しかし、ドライバーの更新タイミングにおいて、OS がレジストリへの書き込み処理を行わない問題があるため、システムの再起動等を行うと、印刷設定が保存されなかったり、プリンタードライバーが予期せぬ挙動を示したりする場合があります。 回避方法以下の OS のバージョンでは修正されております。 ・Windows 11・Windows 10 21H2 (2022 年 6 月 28 日 — KB5014666 (OS ビルド 19042.1806、19043.1806、19044.1806) プレビュー) 以降の更新プログラムが適用されている環境それ以外の OS バージョンでは、明示的に SetPrinter を呼び出して DEVMODE が格納されているレジストリの更新を行います。なお、この際、スプーラーサービスが保持している DEVMODEと同じ値で SetPrinter を実行した場合、レジストリの更新が行われないため、次のように確実にてレジストリが更新されるよう、一時的に DEVMODE の値を変更して SetPrinter を 実行します。回避方法としては、プリンタ―ドライバ―のアップデート後に、GetPrinter を1回、SetPrinter を2回呼び出します。１．まず、GetPrinter を呼び出して、現在の DEVMODE を取得します。２．続いて、1で取得した現在の DEVMODE から、値を変更（例えば、dmOrientation の値など）した DEVMODE を SetPrinter でセットします。この時、レジストリが更新されます。３．最後に 1 で取得した現在の DEVMODE をそのまま、SetPrinter でセットし、値を元に戻し、かつレジストリも再度更新します。Modify printer settings by using the SetPrinter function のサンプル コードをベースとした回避方法の例となります。上記 「１．まず、GetPrinter を呼び出して、現在の DEVMODE を取得します。」については、dmOrientation の値を変更するための DEVMODE と 「３．最後に 1 で取得した現在の DEVMODE をそのまま、SetPrinter でセットし、値を元に戻し、かつレジストリも再度更新します。」で 元に戻す DEVMODE を取得するために 2 回 GetPrinter を呼び出しています。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// MySetPrinter// Demonstrates how to use the SetPrinter API. This particular function changes the orientation// for the printer specified in pPrinterName to the orientation specified in dmOrientation.// Valid values for dmOrientation are:// DMORIENT_PORTRAIT (1) or DMORIENT_LANDSCAPE (2)BOOL MySetPrinter(LPTSTR pPrinterName, short dmOrientation)&#123; HANDLE hPrinter = NULL; DWORD dwNeeded = 0; PRINTER_INFO_2 *pi2 = NULL; PRINTER_INFO_2 *pi2_org = NULL; DEVMODE *pDevMode = NULL; PRINTER_DEFAULTS pd; BOOL bFlag; LONG lFlag; // Open printer handle (on Windows NT, you need full-access because you // will eventually use SetPrinter)... ZeroMemory(&amp;pd, sizeof(pd)); pd.DesiredAccess = PRINTER_ALL_ACCESS; bFlag = OpenPrinter(pPrinterName, &amp;hPrinter, &amp;pd); if (!bFlag || (hPrinter == NULL)) return FALSE; // The first GetPrinter tells you how big the buffer should be in // order to hold all of PRINTER_INFO_2. Note that this should fail with // ERROR_INSUFFICIENT_BUFFER. If GetPrinter fails for any other reason // or dwNeeded isn&#x27;t set for some reason, then there is a problem... SetLastError(0); bFlag = GetPrinter(hPrinter, 2, 0, 0, &amp;dwNeeded); if ((!bFlag) &amp;&amp; (GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (dwNeeded == 0)) &#123; ClosePrinter(hPrinter); return FALSE; &#125; // Allocate enough space for PRINTER_INFO_2... pi2 = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded); if (pi2 == NULL) &#123; ClosePrinter(hPrinter); return FALSE; &#125; //１．まず、GetPrinter を呼び出して、現在の DEVMODE を取得します。 //３．で DEVMODE の値を戻すために呼び出します。 // The second GetPrinter fills in all the current settings, so all you // need to do is modify what you&#x27;re interested in... bFlag = GetPrinter(hPrinter, 2, (LPBYTE)pi2, dwNeeded, &amp;dwNeeded); if (!bFlag) &#123; GlobalFree(pi2); ClosePrinter(hPrinter); return FALSE; &#125; pi2_org = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded); if (pi2_org == NULL) &#123; GlobalFree(pi2); ClosePrinter(hPrinter); return FALSE; &#125; //１．GetPrinter を呼び出して、現在の DEVMODE を取得します。 //２．で dmOrientation の値を変更するために呼び出します。 bFlag = GetPrinter(hPrinter, 2, (LPBYTE)pi2_org, dwNeeded, &amp;dwNeeded); if (!bFlag) &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; // Driver is reporting that it doesn&#x27;t support this change... if (!(pi2-&gt;pDevMode-&gt;dmFields &amp; DM_ORIENTATION)) &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; // Specify exactly what we are attempting to change... pi2-&gt;pDevMode-&gt;dmFields = DM_ORIENTATION; pi2-&gt;pDevMode-&gt;dmOrientation = dmOrientation; // Do not attempt to set security descriptor... pi2-&gt;pSecurityDescriptor = NULL; //２．続いて、１で取得した現在の DEVMODE から、値を変更（例えば、dmOrientation の値など）した //DEVMODE を SetPrinter でセットします。この時、レジストリが更新されます。 // Update printer information... bFlag = SetPrinter(hPrinter, 2, (LPBYTE)pi2, 0); if (!bFlag) // The driver doesn&#x27;t support, or it is unable to make the change... &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; //３．最後に 1 で取得した現在の DEVMODE をそのまま、SetPrinter でセットし、値を元に戻し、かつレジストリも再度更新します。 bFlag = SetPrinter(hPrinter, 2, (LPBYTE)pi2_org, 0); if (!bFlag) &#123; GlobalFree(pi2); GlobalFree(pi2_org); ClosePrinter(hPrinter); return FALSE; &#125; // Tell other apps that there was a change... SendMessageTimeout(HWND_BROADCAST, WM_DEVMODECHANGE, 0L, (LPARAM)(LPCSTR)pPrinterName, SMTO_NORMAL, 1000, NULL); // Clean up... if (pi2_org) GlobalFree(pi2_org); if (pi2) GlobalFree(pi2); if (hPrinter) ClosePrinter(hPrinter); if (pDevMode) GlobalFree(pDevMode); return TRUE;&#125; 参考情報SetPrinter 関数GetPrinter 関数DEVMODEW 構造体 変更履歴2022&#x2F;09&#x2F;20 created by mitsuchi ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"devmode","slug":"devmode","permalink":"https://jpwdkblog.github.io/blog/tags/devmode/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"UWP アプリから nul ポートが指定されているプリンターに印刷できない","slug":"printer-null-port-issue","date":"2022-03-10T08:30:00.000Z","updated":"2026-02-05T09:21:50.100Z","comments":true,"path":"2022/03/10/printer-null-port-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2022/03/10/printer-null-port-issue/","excerpt":"この記事では、Windows 10 における印刷における問題について説明します。","text":"この記事では、Windows 10 における印刷における問題について説明します。 概要現在、Windows 10 の 2021 年 12 月 14 日— KB5008212 (OS ビルド 19041.1415、19042.1415、19043.1415、および 19044.1415) を適用した環境において、UWP アプリから nul: ポートが指定されているプリンターで印刷が失敗することを確認しています。 現象次のような条件で問題が発生します。 プリンターのプロパティにて、プリンター ポートとして次のように nul: が指定されています。 [フォト] などの UWP ベースのアプリから印刷します。 その結果、次のようなエラーが発生します。 解決方法2022&#x2F;6&#x2F;2 の更新プログラム KB5014023 (OS Builds 19042.1741, 19043.1741, and 19044.1741) にて、この問題について者は修正されました。 June 2, 2022—KB5014023 (OS Builds 19042.1741, 19043.1741, and 19044.1741) Preview https://support.microsoft.com/en-us/topic/june-2-2022-kb5014023-os-builds-19042-1741-19043-1741-and-19044-1741-preview-65ac6a5d-439a-4e88-b431-a5e2d4e2516a 変更履歴2022/03/10 created by riwaida2022/10/02 modified by riwaida: 更新プログラムの情報追加 ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"Windows 10","slug":"Windows-10","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-10/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Windows 11 における USB スキャナーで発生する問題について","slug":"win11-usbscan-issue","date":"2021-12-28T00:00:00.000Z","updated":"2026-02-05T09:21:50.269Z","comments":true,"path":"2021/12/28/win11-usbscan-issue/","link":"","permalink":"https://jpwdkblog.github.io/blog/2021/12/28/win11-usbscan-issue/","excerpt":"この記事では、Windows 11 に USB スキャナーを接続した問題について説明します。","text":"この記事では、Windows 11 に USB スキャナーを接続した問題について説明します。 概要現在、Windows 11 において、次のような操作を行うと USB スキャナーのドライバーのロードに失敗して、スキャナーが正しく動作しない問題があることを確認しています。 (1) Windows が起動している状態で USB スキャナーを接続します。 (2) スキャナーと PC が接続されている USB ケーブルを抜く、またはスキャナーの電源をオフにします。 (3) Windows を再起動します。 (4) Windows 起動後、再度 USB スキャナーを接続、あるいは電源をオンにします。 結果：USB スキャナーを使用するアプリケーションを起動し、スキャナーの利用を試みると、スキャナー ドライバーの有無に関わらず [このデバイスを使用するには WIA ドライバーが必要です。] というエラーが表示されます。 状況この現象については Windows 11 の不具合であり 2022&#x2F;9&#x2F;20 に公開された更新プログラム KB5017383 (OS Build 22000.1042) 以降で修正されました。 September 20, 2022—KB5017383 (OS Build 22000.1042) Previewhttps://support.microsoft.com/en-us/topic/september-20-2022-kb5017383-os-build-22000-1042-preview-62753265-68e9-45d2-adcb-f996bf3ad393 開発者向け詳細情報この現象による問題かどうかについては c:\\windows\\debug\\WIA\\wiatrace.log を参照することで、判断することができます。Windows 11 において、ドライバーをインストールしているにもかかわらず、概要に記載のようなエラーが表示される場合、WIA Trace Log に次のようなログが出力されていないかご確認ください。USDWrapper::LoadDriver のエラーコードとして hr = 0x80070057 が記録されている場合、この現象に該当していると考えられます。 12WIA: xxxx.yyy zzz 0 0 [wiaservc.dll] ERROR: USDWrapper::LoadDriver, We encountered an error attempting to load driver for (YourScannerName), error (0x80070057)WIA: xxxx.yyy zzz 0 0 [wiaservc.dll] ERROR: DeviceListManager::ProcessDeviceArrival, The driver for device (YourScannerName) failed to load (hr = 0x80070057) 変更履歴2021/12/31 created by riwaida2022/10/20 modified by riwaida : 更新プログラムの情報追加 ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}],"tags":[{"name":"Windows 11","slug":"Windows-11","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11/"}],"keywords":[{"name":"printscan","slug":"printscan","permalink":"https://jpwdkblog.github.io/blog/categories/printscan/"}]},{"title":"Windows 11 及び Server 2022 用 HLK の Create project のダイアログの \"Is Windows Driver Project?\" にチェックは入れないでください","slug":"HLK-create-project","date":"2021-07-12T15:00:00.000Z","updated":"2026-02-05T09:21:50.011Z","comments":true,"path":"2021/07/13/HLK-create-project/","link":"","permalink":"https://jpwdkblog.github.io/blog/2021/07/13/HLK-create-project/","excerpt":"Windows 11 及び Server 2022 用 HLK の Create project を実行する際の、”Is Windows Driver Project?” チェックボックスについて注意点を紹介いたします。","text":"Windows 11 及び Server 2022 用 HLK の Create project を実行する際の、”Is Windows Driver Project?” チェックボックスについて注意点を紹介いたします。 Windows 11 HLK 及び Windows HLK for Windows Server 2022 では、「手順 4:プロジェクトの作成」の際に、以下のような “Is Windows Driver Project?” というチェックボックスがある “Create project” のダイアログが表示されます。 誠に恐れ入りますが、Windows 11 や Windows Server 2022 用の認定や署名の取得のために、Hardware Dev Center Dashboard に提出される場合には、このチェックボックスに チェックは入れない ようにお願いいたします。 このチェックボックスは、本来 Dashboard へのご提出用を目的としておらず、弊社開発部門等と協業されているお客様が、その担当部門より指示があった場合にご利用されるものとなっており、将来削除予定となっております。 もしこれをチェックしてプロジェクトを作成して提出された場合、Hardware Dev Center Dashboard 側ではそれを処理できず、ご提出は Pass せず止まったまま、もしくは、Dashboard 側の担当部門にて Cancel の取り扱いとなります。この場合、Windows 11 HLK 及び Windows HLK for Windows Server 2022 でのご提出をご要望される場合は、以下のいずれかの対処策があります。 (a) 上記プロジェクトの作成をチェックボックスにチェックを入れずにやり直し、DF - InfVerif INF Verification (bbcc1b46-d0bf-46c8-85b4-2cd62df34a20) のみ実施します。そして、HLK Studio の Package タブの [Add Supplemental Folder] ボタンでSupplemental folder に以下を追加した提出パッケージを作成します。 上記の提出が Pass しなかった HLKX ファイル Waiver ID Number に 84015 (という Manual Errata ID) をご記載いただいた、WHQL Submission Readme フォーム (b) 万が一、何らかの理由で (a) の方法がうまくいかない場合は、上記プロジェクトの作成からチェックを入れずにやり直し、テストを全て再度ご実施いただきます。 上記の問題を弊社は認識しておりますため、改善に向けたアクションを進めております。ただ、誠に恐れ入りますが、現時点では、上記の回避策があるため、Windows 11 HLK 及び Windows HLK for Windows Server 2022 そのものの修正は行われず、次のバージョンのリリースに修正が含まれる予定です。そのため、誠にお手数ではございますが、Windows 11 HLK 及び Windows HLK for Windows Server 2022 につきましては、上記の対処でのご対応をお願い申し上げます。 参考 URLWindows 11 &amp; Server 2022 HLK kit guidance for creating new submission packages for Widows 11, v21H2 変更履歴2021/07/13 created by Tsuda2021/07/20 modified by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Hardware Lab Kit","slug":"Hardware-Lab-Kit","permalink":"https://jpwdkblog.github.io/blog/categories/Hardware-Lab-Kit/"}],"tags":[{"name":"Windows 11 HLK","slug":"Windows-11-HLK","permalink":"https://jpwdkblog.github.io/blog/tags/Windows-11-HLK/"}],"keywords":[{"name":"Hardware Lab Kit","slug":"Hardware-Lab-Kit","permalink":"https://jpwdkblog.github.io/blog/categories/Hardware-Lab-Kit/"}]},{"title":"Windows PE 用ドライバの開発において参考になる公開ドキュメントについて","slug":"winpe-reference-websites","date":"2020-08-11T03:00:00.000Z","updated":"2026-02-05T09:21:50.300Z","comments":true,"path":"2020/08/11/winpe-reference-websites/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/08/11/winpe-reference-websites/","excerpt":"Windows PE で動作するドライバを開発していただくにあたり、ご参照いただける公開ドキュメントをこちらにまとめてご紹介をいたします。","text":"Windows PE で動作するドライバを開発していただくにあたり、ご参照いただける公開ドキュメントをこちらにまとめてご紹介をいたします。 これをご案内する背景として、上記を実現するために必要な公開情報はあるものの、Windows PE で動作するドライバを開発する、という目的で一元化してはおりませんため、それらをおまとめした今回のブログがお役に立てば幸いです。 ドライバの実装そのものに Windows PE のために特別必要な実装はございませんので、インストール方法とデバッグ方法について以下の通りご案内いたします。 ドライバのインストール方法 Add and Remove Drivers to an offline Windows Image Add Device Drivers to Windows During Windows Setup WinPE:マウントとカスタマイズ デバイス ドライバー (.inf ファイル) を追加する WinPE イメージにデバイス ドライバーを追加するには、DISM &#x2F;add-driver を使用します。 Dism &#x2F;Add-Driver &#x2F;Image:”C:\\WinPE_amd64\\mount” &#x2F;Driver:”C:\\SampleDriver\\driver.inf” 1 つのコマンドを使用してイメージに複数のドライバーを追加できますが、ほとんどの場合、各ドライバー パッケージを個別に追加すると問題のトラブルシューティングが簡単になります。ドライバーの詳細については、デバイス ドライバー (.inf ファイル) の追加 に関するページを参照してください。 使用可能なすべての DISM ドライバー サービス オプションを確認するには、DISM ドライバー サービスのコマンド ライン オプション に関するページを参照してください。 Drvload Command-Line Options The Drvload tool adds out-of-box drivers to a booted Windows Preinstallation Environment (Windows PE) image. It takes one or more driver .inf files as inputs. To add a driver to an offline Windows PE image, use the Deployment Image Servicing and Management (DISM) tool. For more information, see Add and Remove Drivers to an Offline Windows Image. If the driver .inf file requires a reboot, Windows PE will ignore the request. If the driver .sys file requires a reboot, then the driver cannot be added with Drvload. For more information, see Device Drivers and Deployment Overview and DISM Driver Servicing Command-Line Options. Drivers added using the Drvload tool are marked as the preferred driver for that device. If you add an updated driver during Windows Setup, the driver that you added with Drvload takes precedence. ドライバのデバッグ方法 WinPE: Debug Apps - Kernel-mode debugging 上記に関連して、以下のブログも作成しておりますので、ご参考になりましたら幸いです。 Windows PE でのネットワーク経由カーネル デバッガ接続方法について Windows PE で IOCTL サンプルを動作させる方法について 以上の内容がお役に立てば幸いです。 変更履歴2020/08/11 created by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}],"tags":[{"name":"参考情報","slug":"参考情報","permalink":"https://jpwdkblog.github.io/blog/tags/%E5%8F%82%E8%80%83%E6%83%85%E5%A0%B1/"}],"keywords":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}]},{"title":"Windows PE で IOCTL サンプルを動作させる方法について","slug":"IOCTL-sample","date":"2020-07-29T08:30:00.000Z","updated":"2026-02-05T09:21:50.026Z","comments":true,"path":"2020/07/29/IOCTL-sample/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/07/29/IOCTL-sample/","excerpt":"Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。","text":"Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。 今回は、Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。 IOCTL サンプル サイト Windows PE でご自身のドライバがうまく動作しない場合の、比較の一助になれば幸いです。 前提今回は、以前ご案内した以下のブログと同じ環境がすでにあることを前提とします。 Windows PE でのネットワーク経由のカーネルデバッガ接続方法 上記で使用している ISO を上書きすることになるため、仮想マシンはシャットダウン (電源 OFF でもよいです) し、カーネルデバッガも終了しておきます。また、今回はあくまでもテスト目的のため、通常必要となる以下の方法での INF ファイルのドライバインストール方法を使っていない点にご留意ください。 WinPE:マウントとカスタマイズ - デバイス ドライバー (.inf ファイル) を追加する 今回使用する IOCTL のサンプルにも、運用環境で使用してはいけない旨記載されております。 IOCTL サンプル サイト 抜粋: [!CAUTION] This sample driver is not a Plug and Play driver. This is a minimal driver meant to demonstrate a feature of the operating system. Neither this driver nor its sample programs are intended for use in a production environment. Instead, they are intended for educational purposes and as a skeleton driver. 手順(1) IOCTL サンプルを Visual Studio 2019 で x64 &#x2F; Debug でビルドします。 1-1. サンプルの入手 IOCTL サンプルは、以下のサイトの右側の緑色の [Code] ボタンを押すと表示される [Download ZIP] ボタンで Windows-driver-samples-master.zipをダウンロードすると、Windows-driver-samples-master\\general\\ioctl\\wdm のフォルダにあります。 https://github.com/Microsoft/Windows-driver-samples 1-2. サンプルのビルド このフォルダの ioctl.sln を、Visual Studio 2019 で開きます。Exe フォルダの下にはユーザーモードアプリケーションである ioctlapp のプロジェクト、Sys フォルダの下にはカーネルモードドライバである sioctl のプロジェクトがあることを確認できます。 [ソリューション ‘ioctl’] を右クリックして [構成マネージャー] をクリックします。 今回は、[アクティブソリューション構成] を **[Debug]**、[アクティブ ソリューション プラットフォーム] を [x64] とします。 また、ioctlapp のプロパティを開き、[構成プロパティ]-[C&#x2F;C++]-[コード生成] の [ランタイム ライブラリ] は [マルチスレッド デバッグ (&#x2F;MTd)] にしておきます。 [ソリューション ‘ioctl’] を右クリックして [ソリューションのリビルド] をクリックします。 これで、ioctlapp.exe, sioctl.sys ができます。 次のステップに必要なファイルと場所は以下です。 ファイル 場所 ioctlapp.exe&amp;nbsp;&amp;nbsp;&amp;nbsp; ioctl\\wdm\\exe\\x64\\Debug sioctl.sys&amp;nbsp;&amp;nbsp;&amp;nbsp; ioctl\\wdm\\sys\\x64\\Debug (2) 管理者権限で起動された [展開およびイメージング ツール環境] で、以下のコマンドを実行します。(作業用ディレクトリは、前回の記事の前提のまま D:\\WinPE_amd64 とします。) 2-1. テスト署名が利用可能になるようにします。 1&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /set &#123;default&#125; testsigning on 2-2. 上述のアプリケーションとドライバのファイルを WinPE のイメージにコピーするために、WinPE のイメージをマウントします。 1&gt; Dism /Mount-Image /ImageFile:&quot;D:\\WinPE_amd64\\media\\sources\\boot.wim&quot; /index:1 /MountDir:&quot;D:\\WinPE_amd64\\mount&quot; 参考: Windows PE ブート イメージをマウントする 2-3. マウントした WinPE のイメージに、上述のアプリケーションとドライバのファイルをコピーします。ここでは例として \\Windows\\Ioctl というフォルダにコピーするとします。 123&gt; xcopy D:\\develop\\blog\\ioctl\\wdm\\sys\\x64\\Debug\\sioctl.sys &quot;D:\\WinPE_amd64\\mount\\Windows\\Ioctl&quot;&gt; xcopy D:\\develop\\blog\\ioctl\\wdm\\exe\\x64\\Debug\\ioctlapp.exe &quot;D:\\WinPE_amd64\\mount\\Windows\\Ioctl&quot; 2-4. WinPE イメージのマウントを解除し、変更をコミットします。 1&gt; Dism /Unmount-Image /MountDir:&quot;D:\\WinPE_amd64\\mount&quot; /commit 参考: Windows PE イメージのマウントを解除し、メディアを作成する 2-5. 上記が完了したら、以下のコマンドで Windows PE の ISO ファイルを作成します。 1&gt; makewinpemedia /iso d:\\WinPE_amd64\\winpe_x64_debug.iso (3) 「Windows PE でのネットワーク経由のカーネルデバッガ接続方法」の記事で作成した仮想マシンを起動すると、上記の ISO ファイルで起動します。 (4) カーネルデバッガ側は、以下のコマンドを実行することで Windows PE のターゲットにデバッガ接続し、ブレークインできます。 1&gt; windbg.exe -k net:port=50005,key=5.5.5.5 (5) カーネルデバッガ側では、Symbol Search Path に上記 1-2. の sioctl.sys と ioctlapp.exe のシンボルファイル (sioctl.pdb と ioctlapp.pdb) の存在するフォルダへのフルパスを追記しておきます。 (6) カーネルデバッガの Commands ウィンドウで以下のコマンドを実行して、sioctl.sys の DriverEntry にブレークポイントを貼ってから g を実行します。 1&gt; bp sioctl!DriverEntry (7) 仮想マシン上で開いているコマンドプロンプト上で、以下を実行します。 7-1. ioctlapp.exe のある \\Windows\\Ioctl フォルダに移動します。 1&gt; cd \\Windows\\Ioctl 7-2. ioctlapp.exe をオプションなしで実行します。 1&gt; ioctlapp.exe (8) カーネルデバッガ側で sioctl!DriverEntry にブレークインします。自動的に ioctl\\wdm\\sys\\sioctl.c が開かない場合には開きます。 (9) Commands ウィンドウで p などを入力して、161 行目の「return status;」までステップ実行します。ここで、!drvobj sioctl 2 と実行すれば、132 行目で「DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] &#x3D; SioctlCreateClose;」を実行している通り、以下のように、IOCTL_MJ_CREATE のコールバックに SIoctl!SioctlCreateClose がセットされていることがわかります。 1234567891011121314151617181920212223242526272829303132333435363738kd&gt; !drvobj sioctl 2Driver object (ffffd18d336f0e40) is for:\\Driver\\SIoctlDriverEntry: fffff80822a76150 SIoctl!GsDriverEntryDriverStartIo: 00000000 DriverUnload: fffff80822a759e0 SIoctl!SioctlUnloadDriverAddDevice: 00000000 Dispatch routines:[00] IRP_MJ_CREATE fffff80822a751d0 SIoctl!SioctlCreateClose &lt;&lt;&lt;&lt;&lt; ★[01] IRP_MJ_CREATE_NAMED_PIPE fffff80627dccd40 nt!IopInvalidDeviceRequest[02] IRP_MJ_CLOSE fffff80822a751d0 SIoctl!SioctlCreateClose[03] IRP_MJ_READ fffff80627dccd40 nt!IopInvalidDeviceRequest[04] IRP_MJ_WRITE fffff80627dccd40 nt!IopInvalidDeviceRequest[05] IRP_MJ_QUERY_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[06] IRP_MJ_SET_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[07] IRP_MJ_QUERY_EA fffff80627dccd40 nt!IopInvalidDeviceRequest[08] IRP_MJ_SET_EA fffff80627dccd40 nt!IopInvalidDeviceRequest[09] IRP_MJ_FLUSH_BUFFERS fffff80627dccd40 nt!IopInvalidDeviceRequest[0a] IRP_MJ_QUERY_VOLUME_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[0b] IRP_MJ_SET_VOLUME_INFORMATION fffff80627dccd40 nt!IopInvalidDeviceRequest[0c] IRP_MJ_DIRECTORY_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[0d] IRP_MJ_FILE_SYSTEM_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[0e] IRP_MJ_DEVICE_CONTROL fffff80822a75250 SIoctl!SioctlDeviceControl[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[10] IRP_MJ_SHUTDOWN fffff80627dccd40 nt!IopInvalidDeviceRequest[11] IRP_MJ_LOCK_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[12] IRP_MJ_CLEANUP fffff80627dccd40 nt!IopInvalidDeviceRequest[13] IRP_MJ_CREATE_MAILSLOT fffff80627dccd40 nt!IopInvalidDeviceRequest[14] IRP_MJ_QUERY_SECURITY fffff80627dccd40 nt!IopInvalidDeviceRequest[15] IRP_MJ_SET_SECURITY fffff80627dccd40 nt!IopInvalidDeviceRequest[16] IRP_MJ_POWER fffff80627dccd40 nt!IopInvalidDeviceRequest[17] IRP_MJ_SYSTEM_CONTROL fffff80627dccd40 nt!IopInvalidDeviceRequest[18] IRP_MJ_DEVICE_CHANGE fffff80627dccd40 nt!IopInvalidDeviceRequest[19] IRP_MJ_QUERY_QUOTA fffff80627dccd40 nt!IopInvalidDeviceRequest[1a] IRP_MJ_SET_QUOTA fffff80627dccd40 nt!IopInvalidDeviceRequest[1b] IRP_MJ_PNP fffff80627dccd40 nt!IopInvalidDeviceRequest (10) カーネルデバッガの Commands ウィンドウで以下のコマンドを実行して、sioctl.sys の SioctlCreateClose にブレークポイントを貼ってから g を実行します。 1&gt; bp sioctl!SioctlCreateClose (11) カーネルデバッガ側で SIoctl!SioctlCreateClose にブレークインします。k を実行すると、確かに ioctlapp.exe の main 関数の CreateFile からオープンされたことが確認できます。 1234567891011121314151617kd&gt; k# Child-SP RetAddr Call Site00 ffff9088`d85c73d8 fffff806`27cceda9 SIoctl!SioctlCreateClose [D:\\develop\\blog\\ioctl\\wdm\\sys\\sioctl.c @ 192] 01 (Inline Function) --------`-------- nt!IopfCallDriver+0x4402 ffff9088`d85c73e0 fffff806`27ccde54 nt!IofCallDriver+0x5903 ffff9088`d85c7420 fffff806`282b9b6b nt!IoCallDriverWithTracing+0x3404 ffff9088`d85c7470 fffff806`282c09af nt!IopParseDevice+0x62b05 ffff9088`d85c75e0 fffff806`282bee11 nt!ObpLookupObjectName+0x78f06 ffff9088`d85c77a0 fffff806`282d99aa nt!ObOpenObjectByNameEx+0x20107 ffff9088`d85c78e0 fffff806`282d9599 nt!IopCreateFile+0x3fa08 ffff9088`d85c7980 fffff806`27e74e95 nt!NtCreateFile+0x7909 ffff9088`d85c7a10 00007ffc`ff25cb04 nt!KiSystemServiceCopyEnd+0x250a 000000ae`5e8ff408 00007ffc`fd1c45e4 ntdll!ZwCreateFile+0x140b 000000ae`5e8ff410 00007ffc`fd1c422f KERNELBASE!CreateFileInternal+0x2f40c (Inline Function) --------`-------- KERNELBASE!CreateFileW+0x6a0d 000000ae`5e8ff580 00007ff7`9ec81cd2 KERNELBASE!CreateFileA+0xbf0e 000000ae`5e8ff5f0 00000000`00000000 ioctlapp!main+0x142 [D:\\develop\\blog\\ioctl\\wdm\\exe\\testapp.c @ 106] Testapp.c の 106 行目のコードは、確かに以下の通り CreateFile() を実行しています。 これでオープンできているのは、sioctl.sys で以下のように、IoCreateDevice() の第 3 引数 ntUnicodeString で \\Device\\SIOCTL という NT Device Name をセットしており、かつ、これに対するシンボリックリンクとして、Win32 Name である \\DosDevices\\IoctlTest を IoCreateSymbolicLink() で作成しているためです。 参考:Introduction to MS-DOS Device Names ただ、上記のドキュメントにも以下の抜粋の様にある通り、上記の方法を取るのは、一般には非 WDM ドライバです。WDM ドライバは一般的にはデバイスインターフェースを登録して使用します。 抜粋： A named device object that is created by a non-WDM driver typically has an MS-DOS device name. An MS-DOS device name is a symbolic link in the object manager with a name of the form \\DosDevices\\DosDeviceName. WDM drivers do not usually supply MS-DOS device names for their devices. Instead, WDM drivers use the IoRegisterDeviceInterface routine to register a device interface. The device interface specifies devices by their capabilities, rather than by a particular naming convention. For more information, see Device Interface Classes. KMDF など WDF については、以下のドキュメントもご参考ください。Using Device Interfaces (12) 最終的に仮想マシン上のコマンドプロンプトには、ioctlapp.exe の実行結果として、以下が表示されて、問題なく動作できていることがわかります。(各 IOCTL の動作を確認したい場合は、上記を参考に SIoctl!SioctlDeviceControl にブレークポイントを貼ってみてください。) 以上の内容がお役に立てば幸いです。 変更履歴2020/07/29 created by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}],"tags":[{"name":"IOCTL","slug":"IOCTL","permalink":"https://jpwdkblog.github.io/blog/tags/IOCTL/"}],"keywords":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}]},{"title":"Windows PE でのネットワーク経由カーネル デバッガ接続方法について","slug":"winpe-kernel-debug-via-network","date":"2020-07-29T08:00:00.000Z","updated":"2026-02-05T09:21:50.286Z","comments":true,"path":"2020/07/29/winpe-kernel-debug-via-network/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/07/29/winpe-kernel-debug-via-network/","excerpt":"Windows PE でのネットワーク経由のカーネルデバッガ接続方法についてご紹介します。","text":"Windows PE でのネットワーク経由のカーネルデバッガ接続方法についてご紹介します。 Windows PE でのシリアルケーブル経由でのカーネルデバッガ接続方法は、以下のドキュメントが公開されております。この方法では、カーネルデバッガを起動する側であるホスト PC を選びません。 WinPE: Debug Apps - Kernel-mode debugging 対しまして、今回ご紹介するネットワーク経由のカーネルデバッガ接続方法では、通常、以下のブログでご紹介したような kdnet.exe は、ターゲット PC の再起動が必要となるため使えず、予めホスト PC の IP アドレスを Windows PE 側の BCD に設定しておく必要があります。 Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法 それでは、具体的な手順を紹介します。 前提今回は、Windows PE のイメージ作成を行う環境と、カーネルデバッガを起動するホスト PC は同じ PC とします。そして、その PC の Hyper-V 仮想マシン (UEFI を使うため第二世代、セキュアブートは OFF) を、ターゲット PC として、Windows PE の ISO を読ませるようにします。 ホスト PC には、以下のリンクから、Windows ADK for Windows 10 バージョン 1903 と、ADK 用の Windows PE アドオンをインストールしています。 Windows ADK のダウンロードとインストール Windows ADK for Windows 10、バージョン 1903 のダウンロード ADK 用の Windows PE アドオンのダウンロード 手順(1) [スタート] -&gt; [Windows Kits] -&gt; [展開およびイメージング ツール環境] を管理者権限で起動します。 (2) copype.exe で、例として D:\\WinPE_amd64 に作業用ディレクトリを作成します。(D ドライブの使用は例であり、任意の場所で問題ありません。また、すでに D:\\WinPE_amd64 が存在する場合は、コマンドがエラーとなるため、事前に削除しておきます。) 1&gt; copype amd64 d:\\WinPE_amd64 (3) 以下のコマンドを実行し、Windows PE 環境側のネットワーク接続でのカーネルデバッグ設定を行います。 (3-A) Windows PE 環境が UEFI の場合 12345&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /set &#123;default&#125; debug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /set &#123;default&#125; bootdebug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /dbgsettings NET HOSTIP:&lt;カーネルデバッガを起動するホスト PC の IP アドレス、xxx.xxx.xxx.xxx&gt; PORT:50005 key:5.5.5.5 (3-B) Windows PE 環境がレガシー BIOS の場合 12345&gt; bcdedit /store d:\\WinPE_amd64\\media\\Boot\\BCD /set &#123;default&#125; debug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\Boot\\BCD /set &#123;default&#125; bootdebug on&gt; bcdedit /store d:\\WinPE_amd64\\media\\Boot\\BCD /dbgsettings NET HOSTIP:&lt;カーネルデバッガを起動するホスト PC の IP アドレス、xxx.xxx.xxx.xxx&gt; PORT:50005 key:5.5.5.5 PORT の 50005 と key の 5.5.5.5 は例です。 (4) 以下のコマンドを実行し、設定した結果に問題ないか確認します。 123456&gt; bcdedit /store d:\\WinPE_amd64\\media\\EFI\\Microsoft\\Boot\\BCD /dbgsettings key 5.5.5.5 debugtype NET hostip xxx.xxx.xxx.xxx port 50005 dhcp Yes (5) 上記が完了したら、以下のコマンドで Windows PE の ISO ファイルを作成します。 1&gt; makewinpemedia /iso d:\\WinPE_amd64\\winpe_x64_debug.iso (6) 上記の ISO ファイルで Hyper-V 仮想環境 (第二世代、セキュアブートなし) を作成します。 (上記の手順 (3) で、(3-A) で設定を行ったことが前提です。第一世代ですと、UEFI ではないため、(3-B) でないとカーネルデバッグ接続できません。また、セキュアブートは無効にする必要があります。) 使用する仮想スイッチは、上記「Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法」の「1. ホストPC と仮想マシンをネットワーク接続します。」と同じものを使っています。 (7) カーネルデバッガ側は、以下のコマンドを実行することで Windows PE のターゲットにデバッガ接続し、ブレークインできます。 1&gt; windbg.exe -k net:port=50005,key=5.5.5.5 以上の内容がお役に立てば幸いです。 変更履歴2020/07/29 created by Tsuda ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}],"tags":[{"name":"カーネル デバッグ","slug":"カーネル-デバッグ","permalink":"https://jpwdkblog.github.io/blog/tags/%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB-%E3%83%87%E3%83%90%E3%83%83%E3%82%B0/"}],"keywords":[{"name":"Windows PE","slug":"Windows-PE","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-PE/"}]},{"title":"過去ブログについて","slug":"past-blog","date":"2020-01-11T15:00:00.000Z","updated":"2026-02-05T09:21:50.052Z","comments":true,"path":"2020/01/12/past-blog/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/01/12/past-blog/","excerpt":"過去のブログ情報を紹介いたします。","text":"過去のブログ情報を紹介いたします。 WDKWindows Driver Kit サポートチーム フォーラム 抜粋: Windows 10 IoT Core 環境の COM ポートの割り当てについて WIA ミニドライバーサンプル wiadriverex をデバッグする Visual Studio 2015 でのテスト署名方法 カーネルモード デバッガで UMDF ドライバをライブデバッグする V4 プリンター ドライバのデバッガアタッチ方法 デバイスマネージャーの [表示] を [デバイス (接続別)] に切り替える ダンプファイルに保存されたイベントログを取り出す ダンプファイルに保存された ETW トレースログを表示するなど 旧: Japan WDK Support Blog 抜粋: Japan WDK Support Blog 終了のお知らせ Authenticode 署名のドライバインストールのトラブルシューティングの一例 プリンタードライバーの GPD ファイル記述に関する注意事項 Time Travel Debugging (Preview) の Lab Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法 WDK for Windows 10, version 1803 Err.exe でエラーコードの定義を探す Minispy File System Minifilter Driver サンプルを動かしてみるなど 変更履歴2020/01/12 created by Mochizuki2021/04/01 created by Mochizuki ※ 本記事は 「jpwdkblog について」 の留意事項に準じます。※ 併せて 「ホームページ」 および 「記事一覧」 もご参照いただければ幸いです。","categories":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}],"tags":[{"name":"過去ブログ","slug":"過去ブログ","permalink":"https://jpwdkblog.github.io/blog/tags/%E9%81%8E%E5%8E%BB%E3%83%96%E3%83%AD%E3%82%B0/"}],"keywords":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}]},{"title":"jpwdkblog について","slug":"aobut-jpwdkblog","date":"2019-12-31T15:00:00.000Z","updated":"2026-02-05T09:21:50.003Z","comments":true,"path":"2020/01/01/aobut-jpwdkblog/","link":"","permalink":"https://jpwdkblog.github.io/blog/2020/01/01/aobut-jpwdkblog/","excerpt":"","text":"日本マイクロソフトの Windows Driver Kit に関するサポート情報のブログです。 公開日2020 年 1 月 1 日より公開いたしました。 活動について製品のサポート メンバーによって運用されております。仕様に関する情報やトラブル シューティングの手順、実装におけるワンポイント アドバイスを公開いたします。 留意事項サイトのコンテンツや情報において、可能な限り正確な情報を掲載し、更新するよう努めております。しかしながら、状況の変化や情報が古くなることにより、必ずしもお客様環境に適用できない情報となる場合がございます。恐れ入りますが、予めご留意くださいますようお願い申し上げます。","categories":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}],"tags":[{"name":"はじめに","slug":"はじめに","permalink":"https://jpwdkblog.github.io/blog/tags/%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB/"}],"keywords":[{"name":"Windows Driver Kit 全般","slug":"Windows-Driver-Kit-全般","permalink":"https://jpwdkblog.github.io/blog/categories/Windows-Driver-Kit-%E5%85%A8%E8%88%AC/"}]}]}