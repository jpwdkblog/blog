<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shell Launcher でシャットダウンをキャンセルする方法</title>
      <link href="/blog/2020/08/11/Cancel-shutdown-with-Shell-Launcher/"/>
      <url>/blog/2020/08/11/Cancel-shutdown-with-Shell-Launcher/</url>
      
        <content type="html"><![CDATA[<p>Shell Launcher でシャットダウンをキャンセルする方法についてご紹介します。  </p><a id="more"></a><br><hr><p>Shell Launcher でカスタムシェルアプリケーションを実行している時に、シャットダウンの通知を受け取って、未保存のデータを保存してからシャットダウンしたい場合があると思います。 </p><p>例えば、Explorer.exe がシェルとして実行されている時は、実行中のウィンドウ アプリケーションで、以下の様に予め ShutdownBlockReasonCreate() を実行しておき、シャットダウン時に WM_QUERYENDSESSION のウィンドウメッセージを受け取って FALSE を返せば、ユーザーがシャットダウンをキャンセルするかどうかを選ぶことができます。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 選択されたメニューの解析:</span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> HDC を使用する描画コードをここに追加してください...</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        ShutdownBlockReasonCreate(hWnd, <span class="string">L"Don't do it!"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        ShutdownBlockReasonDestroy(hWnd);</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_QUERYENDSESSION:</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jpwdkblog.github.io/images/Cancel-shutdown-with-Shell-Launcher/Closing1app-and-shuttingdown.png" alt="Closing1app-and-shuttingdown.png"></p><p>誠に恐れ入りますが、<strong>Shell Launcher V1 では、制限として、これと同じことができる方法はありません。</strong></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/customize/enterprise/shell-launcher" target="_blank" rel="noopener">Shell Launcher</a></p><blockquote><p>You cannot prevent the system from shutting down. For Shell Launcher V1 and V2, you cannot block the session ending by returning FALSE upon receiving the WM_QUERYENDSESSION message in a graphical application or returning FALSE in the handler routine that is added through the SetConsoleCtrlHandler function in a console application.  </p></blockquote><p>上記ドキュメントでは Shell Launcher V2 でも方法がない旨の記載となっておりますが、現時点では、例外として、Shell Launcher V2 を用いた以下の手順であれば、同じことができることを確認していますので、その詳細をご紹介していきます。  </p><p>今回は、Windows 10 IoT Enterprise LTSC 2019 x64 を使用します。Shell Launcher V2 は Windows 10 バージョン 1809 以降でサポートされており、バージョン 1809 では KB4551853 をインストールすることでご利用いただけます。  </p><h2 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h2><p>(1) Shell Launcher の機能を有効にした Windows 10 IoT Enterprise LTSC 2019 で、以下の KB を適用します。</p><ul><li><p><a href="https://support.microsoft.com/ja-jp/help/4551853/windows-10-update-kb4551853" target="_blank" rel="noopener">2020 年 5 月 12 日 - KB4551853 (OS ビルド 17763.1217)</a></p><p> インターネット接続がある場合は、上記を Windows Update で適用いただくだけで、以下の KB が適用されますが、インターネット接続がない場合には、上記を適用する前に、Microsoft Update カタログから適用ください。</p><p> <a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB4549947" target="_blank" rel="noopener">https://www.catalog.update.microsoft.com/Search.aspx?q=KB4549947</a></p></li></ul><p>(2) ShellLauncherBridgeWmiHelpers.ps1 を以下のサイトからコピーし、 Windows 10 IoT Enterprise LTSC 2019 の PC 上の任意のフォルダ (ここでは例として C:\test とします) に置きます。</p><ul><li><a href="https://docs.microsoft.com/en-us/samples/microsoft/windows-iotcore-samples/samplebridgewmiscripts/" target="_blank" rel="noopener">Shell Launcher V2 Bridge WMI Sample scripts</a></li></ul><p>(3) PsTools.zip を以下からダウンロードし、(2) のフォルダに置き、解凍します。</p><ul><li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec" target="_blank" rel="noopener">PsExec v2.2</a></li></ul><p>(4) (UWP ではない) Windows フォームアプリとして、第二引数にメッセージ付きの ShutdownBlockReasonCreate() と SetProcessShutdownParameters() の第一引数に 0x500 を入れ、WM_QUERYENDSESSION は FALSE で返します。<br>ここでは、例として以下のコードとしています。<br>これをビルドしたモジュールを 2. のフォルダに置きます。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 選択されたメニューの解析:</span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> HDC を使用する描画コードをここに追加してください</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        SetProcessShutdownParameters(<span class="number">0x500</span>, <span class="number">0</span>);</span><br><span class="line">        ShutdownBlockReasonCreate(hWnd, <span class="string">L"Don't do it!"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        ShutdownBlockReasonDestroy(hWnd);</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_QUERYENDSESSION:</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) ShellLauncher.xml の例として、以下の様に記載したものを (2) のフォルダに置きます。Shell= の後にカスタムシェルアプリケーションへのフルパスを記載しています。DefaultAction には、Action=”DoNothing” としています。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ShellLauncherConfiguration</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/ShellLauncher/2018/Configuration"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:v2</span>=<span class="string">"http://schemas.microsoft.com/ShellLauncher/2019/Configuration"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">Profiles</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">DefaultProfile</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">Shell</span> <span class="attr">Shell</span>=<span class="string">"C:\test\SetProcessShutdownParameters.exe"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">DefaultAction</span> <span class="attr">Action</span>=<span class="string">"DoNothing"</span>/&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">Shell</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">DefaultProfile</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">Profiles</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">Configs</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ShellLauncherConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(6) Windows 10 IoT Enterprise LTSC 2019 の PC 上で、管理者権限のコマンドプロンプトから、以下を実行します。これは、システムアカウントで powershell.exe を実行するために必須のため、省略しないようご注意ください。</p><p><code>psexec.exe -i -s powershell.exe</code></p><p>(7) (6) で起動した PowerShell 上で、cd コマンドで 2. のフォルダ (例 C:\test) に移動し、「<code>Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope LocalMachine</code>」などで .ps1 ファイルを実行可能にしたら、以下のコマンドを入力します。</p><p><code>. .\ShellLauncherBridgeWmiHelpers.ps1</code><br><code>Set-ShellLauncherBridgeWmi -FilePath .\ShellLauncher.xml</code></p><p>(8) OS を再起動したら、カスタムシェルアプリケーションが起動してきますので、シャットダウンしますと以下の様に表示されます。Shell Launcher V2 では、カスタムシェルアプリケーションのウィンドウは、必ず全画面表示になりますので、ここでのシャットダウンは、タスクマネージャーの [ファイル]-[新しいタスクの実行] でコマンドプロンプトを起動し、shutdown /s /t 0 を実行しています。  </p><p><img src="https://jpwdkblog.github.io/images/Cancel-shutdown-with-Shell-Launcher/Closing4apps-and-shuttingdown.png" alt="Closing4apps-and-shuttingdown.png"></p><h2 id="参考ドキュメント"><a href="#参考ドキュメント" class="headerlink" title="参考ドキュメント"></a>参考ドキュメント</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/configuration/kiosk-shelllauncher" target="_blank" rel="noopener">Use Shell Launcher to create a Windows 10 kiosk</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-shutdownblockreasoncreate" target="_blank" rel="noopener">ShutdownBlockReasonCreate function</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/shutdown/wm-queryendsession" target="_blank" rel="noopener">WM_QUERYENDSESSION message</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessshutdownparameters" target="_blank" rel="noopener">SetProcessShutdownParameters function</a></li></ul><p>以上の内容がお役に立てば幸いです。</p><hr><p><code>変更履歴</code><br><code>2020/08/11 created by Tsuda</code>  </p>]]></content>
      
      
      <categories>
          
          <category> Shell Launcher </category>
          
      </categories>
      
      
        <tags>
            
            <tag> シャットダウン </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows PE で IOCTL サンプルを動作させる方法について</title>
      <link href="/blog/2020/07/29/IOCTL-sample/"/>
      <url>/blog/2020/07/29/IOCTL-sample/</url>
      
        <content type="html"><![CDATA[<p>Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。</p><a id="more"></a><br><hr><p>今回は、Windows PE で IOCTL サンプルを動作させる方法についてご紹介します。  </p><ul><li><a href="https://github.com/Microsoft/Windows-driver-samples/tree/master/general/ioctl/wdm" target="_blank" rel="noopener">IOCTL サンプル サイト</a>  </li></ul><p>Windows PE でご自身のドライバがうまく動作しない場合の、比較の一助になれば幸いです。  </p><hr><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>今回は、以前ご案内した以下のブログと同じ環境がすでにあることを前提とします。  </p><ul><li><a href="https://jpwdkblog.github.io/blog/2020/07/29/winpe-kernel-debug-via-network/">Windows PE でのネットワーク経由のカーネルデバッガ接続方法</a></li></ul><p>上記で使用している ISO を上書きすることになるため、仮想マシンはシャットダウン (電源 OFF でもよいです) し、カーネルデバッガも終了しておきます。また、今回はあくまでもテスト目的のため、通常必要となる以下の方法での INF ファイルのドライバインストール方法を使っていない点にご留意ください。  </p><ul><li><a href="https://docs.microsoft.com/ja-jp/windows-hardware/manufacture/desktop/winpe-mount-and-customize#span-idadddriversspanadd-device-drivers-inf-files" target="_blank" rel="noopener">WinPE:マウントとカスタマイズ - デバイス ドライバー (.inf ファイル) を追加する</a>  </li></ul><p>今回使用する IOCTL のサンプルにも、運用環境で使用してはいけない旨記載されております。  </p><ul><li><a href="https://github.com/Microsoft/Windows-driver-samples/tree/master/general/ioctl/wdm" target="_blank" rel="noopener">IOCTL サンプル サイト</a> 抜粋:  <blockquote><p>[!CAUTION] This sample driver is not a Plug and Play driver. This is a minimal driver meant to demonstrate a feature of the operating system. Neither this driver nor its sample programs are intended for use in a production environment. Instead, they are intended for educational purposes and as a skeleton driver.  </p></blockquote></li></ul><hr><h3 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h3><p>(1) IOCTL サンプルを Visual Studio 2019 で x64 / Debug でビルドします。  </p><ul><li><p>1-1. サンプルの入手  </p><p> IOCTL サンプルは、以下のサイトの右側の緑色の [Code] ボタンを押すと表示される [Download ZIP] ボタンで Windows-driver-samples-master.zipをダウンロードすると、Windows-driver-samples-master\general\ioctl\wdm のフォルダにあります。<br> <a href="https://github.com/Microsoft/Windows-driver-samples" target="_blank" rel="noopener">https://github.com/Microsoft/Windows-driver-samples</a></p></li><li><p>1-2. サンプルのビルド  </p><p> このフォルダの ioctl.sln を、Visual Studio 2019 で開きます。Exe フォルダの下にはユーザーモードアプリケーションである ioctlapp のプロジェクト、Sys フォルダの下にはカーネルモードドライバである sioctl のプロジェクトがあることを確認できます。  </p> <div align="left"> <img src="https://jpwdkblog.github.io/images/IOCTL-sample/SolutionExplorer.png"> </div><p> <strong>[ソリューション ‘ioctl’]</strong> を右クリックして <strong>[構成マネージャー]</strong> をクリックします。  </p> <div align="left"> <img src="https://jpwdkblog.github.io/images/IOCTL-sample/ConfigurationManager.png"> </div><p> 今回は、[アクティブソリューション構成] を <strong>[Debug]</strong>、[アクティブ ソリューション プラットフォーム] を <strong>[x64]</strong> とします。  </p><p> また、ioctlapp のプロパティを開き、[構成プロパティ]-[C/C++]-[コード生成] の [ランタイム ライブラリ] は <strong>[マルチスレッド デバッグ (/MTd)]</strong> にしておきます。  </p> <div align="left"> <img src="https://jpwdkblog.github.io/images/IOCTL-sample/ioctlappPropatyPage.png"> </div><p> [ソリューション ‘ioctl’] を右クリックして [ソリューションのリビルド] をクリックします。<br> これで、ioctlapp.exe, sioctl.sys ができます。  </p><p> 次のステップに必要なファイルと場所は以下です。</p><table><thead><tr><th align="left">ファイル</th><th align="left">場所</th></tr></thead><tbody><tr><td align="left">ioctlapp.exe&nbsp;&nbsp;&nbsp;</td><td align="left">ioctl\wdm\exe\x64\Debug</td></tr><tr><td align="left">sioctl.sys&nbsp;&nbsp;&nbsp;</td><td align="left">ioctl\wdm\sys\x64\Debug</td></tr></tbody></table></li></ul><p>(2) 管理者権限で起動された [展開およびイメージング ツール環境] で、以下のコマンドを実行します。(作業用ディレクトリは、前回の記事の前提のまま D:\WinPE_amd64 とします。)</p><ul><li><p>2-1. テスト署名が利用可能になるようにします。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\EFI\Microsoft\Boot\BCD &#x2F;set &#123;default&#125; testsigning on</span><br></pre></td></tr></table></figure></li><li><p>2-2. 上述のアプリケーションとドライバのファイルを WinPE のイメージにコピーするために、WinPE のイメージをマウントします。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Dism &#x2F;Mount-Image &#x2F;ImageFile:&quot;D:\WinPE_amd64\media\sources\boot.wim&quot; &#x2F;index:1 &#x2F;MountDir:&quot;D:\WinPE_amd64\mount&quot;</span><br></pre></td></tr></table></figure><p> 参考:<br> <a href="https://docs.microsoft.com/ja-jp/windows-hardware/manufacture/desktop/winpe-mount-and-customize#span-idmount_the_imagespanmount-the-windows-pe-boot-image" target="_blank" rel="noopener">Windows PE ブート イメージをマウントする</a></p></li><li><p>2-3. マウントした WinPE のイメージに、上述のアプリケーションとドライバのファイルをコピーします。ここでは例として \Windows\Ioctl というフォルダにコピーするとします。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; xcopy D:\develop\blog\ioctl\wdm\sys\x64\Debug\sioctl.sys &quot;D:\WinPE_amd64\mount\Windows\Ioctl&quot;</span><br><span class="line"></span><br><span class="line">&gt; xcopy D:\develop\blog\ioctl\wdm\exe\x64\Debug\ioctlapp.exe &quot;D:\WinPE_amd64\mount\Windows\Ioctl&quot;</span><br></pre></td></tr></table></figure></li><li><p>2-4. WinPE イメージのマウントを解除し、変更をコミットします。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Dism &#x2F;Unmount-Image &#x2F;MountDir:&quot;D:\WinPE_amd64\mount&quot; &#x2F;commit</span><br></pre></td></tr></table></figure><p> 参考:<br> <a href="https://docs.microsoft.com/ja-jp/windows-hardware/manufacture/desktop/winpe-mount-and-customize#span-idunmountspanunmount-the-windows-pe-image-and-create-media" target="_blank" rel="noopener">Windows PE イメージのマウントを解除し、メディアを作成する</a>  </p></li><li><p>2-5. 上記が完了したら、以下のコマンドで Windows PE の ISO ファイルを作成します。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; makewinpemedia &#x2F;iso d:\WinPE_amd64\winpe_x64_debug.iso</span><br></pre></td></tr></table></figure></li></ul><p>(3) 「Windows PE でのネットワーク経由のカーネルデバッガ接続方法」の記事で作成した仮想マシンを起動すると、上記の ISO ファイルで起動します。  </p><p>(4) カーネルデバッガ側は、以下のコマンドを実行することで Windows PE のターゲットにデバッガ接続し、ブレークインできます。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; windbg.exe -k net:port&#x3D;50005,key&#x3D;5.5.5.5</span><br></pre></td></tr></table></figure></p><p>(5) カーネルデバッガ側では、Symbol Search Path に上記 1-2. の sioctl.sys と ioctlapp.exe のシンボルファイル (sioctl.pdb と ioctlapp.pdb) の存在するフォルダへのフルパスを追記しておきます。  </p><p>(6) カーネルデバッガの Commands ウィンドウで以下のコマンドを実行して、sioctl.sys の DriverEntry にブレークポイントを貼ってから g を実行します。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bp sioctl!DriverEntry</span><br></pre></td></tr></table></figure></p><p>(7) 仮想マシン上で開いているコマンドプロンプト上で、以下を実行します。  </p><ul><li><p>7-1. ioctlapp.exe のある \Windows\Ioctl フォルダに移動します。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd \Windows\Ioctl</span><br></pre></td></tr></table></figure></li><li><p>7-2. ioctlapp.exe をオプションなしで実行します。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ioctlapp.exe</span><br></pre></td></tr></table></figure></li></ul><p>(8) カーネルデバッガ側で sioctl!DriverEntry にブレークインします。自動的に ioctl\wdm\sys\sioctl.c が開かない場合には開きます。  </p><p>(9) Commands ウィンドウで p などを入力して、161 行目の「return status;」までステップ実行します。ここで、!drvobj sioctl 2 と実行すれば、132 行目で「DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = SioctlCreateClose;」を実行している通り、以下のように、IOCTL_MJ_CREATE のコールバックに SIoctl!SioctlCreateClose がセットされていることがわかります。  </p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> !drvobj sioctl 2</span></span><br><span class="line">Driver object (ffffd18d336f0e40) is for:</span><br><span class="line">\Driver\SIoctl</span><br><span class="line"></span><br><span class="line">DriverEntry:   fffff80822a76150        SIoctl!GsDriverEntry</span><br><span class="line">DriverStartIo: 00000000        </span><br><span class="line">DriverUnload:  fffff80822a759e0        SIoctl!SioctlUnloadDriver</span><br><span class="line">AddDevice:     00000000 </span><br><span class="line"></span><br><span class="line">Dispatch routines:</span><br><span class="line">[00] IRP_MJ_CREATE                      fffff80822a751d0       SIoctl!SioctlCreateClose &lt;&lt;&lt;&lt;&lt; ★</span><br><span class="line">[01] IRP_MJ_CREATE_NAMED_PIPE           fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[02] IRP_MJ_CLOSE                       fffff80822a751d0        SIoctl!SioctlCreateClose</span><br><span class="line">[03] IRP_MJ_READ                        fffff80627dccd40        nt!IopInvalidDeviceRequest</span><br><span class="line">[04] IRP_MJ_WRITE                       fffff80627dccd40        nt!IopInvalidDeviceRequest</span><br><span class="line">[05] IRP_MJ_QUERY_INFORMATION           fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[06] IRP_MJ_SET_INFORMATION             fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[07] IRP_MJ_QUERY_EA                    fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[08] IRP_MJ_SET_EA                      fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[09] IRP_MJ_FLUSH_BUFFERS               fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[0b] IRP_MJ_SET_VOLUME_INFORMATION      fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[0c] IRP_MJ_DIRECTORY_CONTROL           fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[0d] IRP_MJ_FILE_SYSTEM_CONTROL         fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[0e] IRP_MJ_DEVICE_CONTROL              fffff80822a75250       SIoctl!SioctlDeviceControl</span><br><span class="line">[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL     fffff80627dccd40      nt!IopInvalidDeviceRequest</span><br><span class="line">[10] IRP_MJ_SHUTDOWN                    fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[11] IRP_MJ_LOCK_CONTROL                fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[12] IRP_MJ_CLEANUP                     fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[13] IRP_MJ_CREATE_MAILSLOT             fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[14] IRP_MJ_QUERY_SECURITY              fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[15] IRP_MJ_SET_SECURITY                fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[16] IRP_MJ_POWER                       fffff80627dccd40        nt!IopInvalidDeviceRequest</span><br><span class="line">[17] IRP_MJ_SYSTEM_CONTROL              fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[18] IRP_MJ_DEVICE_CHANGE               fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[19] IRP_MJ_QUERY_QUOTA                 fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[1a] IRP_MJ_SET_QUOTA                   fffff80627dccd40       nt!IopInvalidDeviceRequest</span><br><span class="line">[1b] IRP_MJ_PNP                         fffff80627dccd40        nt!IopInvalidDeviceRequest</span><br></pre></td></tr></table></figure><p>(10) カーネルデバッガの Commands ウィンドウで以下のコマンドを実行して、sioctl.sys の SioctlCreateClose にブレークポイントを貼ってから g を実行します。  </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bp sioctl!SioctlCreateClose</span><br></pre></td></tr></table></figure><p>(11) カーネルデバッガ側で SIoctl!SioctlCreateClose にブレークインします。k を実行すると、確かに ioctlapp.exe の main 関数の CreateFile からオープンされたことが確認できます。  </p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Child-SP          RetAddr           Call Site</span></span><br><span class="line">00 ffff9088`d85c73d8 fffff806`27cceda9 SIoctl!SioctlCreateClose [D:\develop\blog\ioctl\wdm\sys\sioctl.c @ 192] </span><br><span class="line">01 (Inline Function) --------`-------- nt!IopfCallDriver+0x44</span><br><span class="line">02 ffff9088`d85c73e0 fffff806`27ccde54 nt!IofCallDriver+0x59</span><br><span class="line">03 ffff9088`d85c7420 fffff806`282b9b6b nt!IoCallDriverWithTracing+0x34</span><br><span class="line">04 ffff9088`d85c7470 fffff806`282c09af nt!IopParseDevice+0x62b</span><br><span class="line">05 ffff9088`d85c75e0 fffff806`282bee11 nt!ObpLookupObjectName+0x78f</span><br><span class="line">06 ffff9088`d85c77a0 fffff806`282d99aa nt!ObOpenObjectByNameEx+0x201</span><br><span class="line">07 ffff9088`d85c78e0 fffff806`282d9599 nt!IopCreateFile+0x3fa</span><br><span class="line">08 ffff9088`d85c7980 fffff806`27e74e95 nt!NtCreateFile+0x79</span><br><span class="line">09 ffff9088`d85c7a10 00007ffc`ff25cb04 nt!KiSystemServiceCopyEnd+0x25</span><br><span class="line">0a 000000ae`5e8ff408 00007ffc`fd1c45e4 ntdll!ZwCreateFile+0x14</span><br><span class="line">0b 000000ae`5e8ff410 00007ffc`fd1c422f KERNELBASE!CreateFileInternal+0x2f4</span><br><span class="line">0c (Inline Function) --------`-------- KERNELBASE!CreateFileW+0x6a</span><br><span class="line">0d 000000ae`5e8ff580 00007ff7`9ec81cd2 KERNELBASE!CreateFileA+0xbf</span><br><span class="line">0e 000000ae`5e8ff5f0 00000000`00000000 ioctlapp!main+0x142 [D:\develop\blog\ioctl\wdm\exe\testapp.c @ 106]</span><br></pre></td></tr></table></figure><p>Testapp.c の 106 行目のコードは、確かに以下の通り CreateFile() を実行しています。  </p><div align="left"><img src="https://jpwdkblog.github.io/images/IOCTL-sample/CreateFile.png"></div><p>これでオープンできているのは、sioctl.sys で以下のように、IoCreateDevice() の第 3 引数 ntUnicodeString で \Device\SIOCTL という NT Device Name をセットしており、かつ、これに対するシンボリックリンクとして、Win32 Name である \DosDevices\IoctlTest を IoCreateSymbolicLink() で作成しているためです。  </p><div align="left"><img src="https://jpwdkblog.github.io/images/IOCTL-sample/IoCreateDevice.png"></div><p>参考:<br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-ms-dos-device-names" target="_blank" rel="noopener">Introduction to MS-DOS Device Names</a></p><p>ただ、上記のドキュメントにも以下の抜粋の様にある通り、上記の方法を取るのは、一般には非 WDM ドライバです。WDM ドライバは一般的にはデバイスインターフェースを登録して使用します。  </p><p>抜粋：  </p><blockquote><p>A named device object that is created by a non-WDM driver typically has an MS-DOS device name. An MS-DOS device name is a symbolic link in the object manager with a name of the form \DosDevices\DosDeviceName.</p></blockquote><blockquote><p>WDM drivers do not usually supply MS-DOS device names for their devices. Instead, WDM drivers use the IoRegisterDeviceInterface routine to register a device interface. The device interface specifies devices by their capabilities, rather than by a particular naming convention. For more information, see Device Interface Classes.</p></blockquote><p>KMDF など WDF については、以下のドキュメントもご参考ください。<br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/wdf/using-device-interfaces" target="_blank" rel="noopener">Using Device Interfaces</a></p><p>(12) 最終的に仮想マシン上のコマンドプロンプトには、ioctlapp.exe の実行結果として、以下が表示されて、問題なく動作できていることがわかります。(各 IOCTL の動作を確認したい場合は、上記を参考に SIoctl!SioctlDeviceControl にブレークポイントを貼ってみてください。)  </p><div align="left"><img src="https://jpwdkblog.github.io/images/IOCTL-sample/SIoctl_SioctlDeviceControl.png"></div><br><p>以上の内容がお役に立てば幸いです。  </p><hr><p><code>変更履歴</code><br><code>2020/07/29 created by Tsuda</code>  </p>]]></content>
      
      
      <categories>
          
          <category> Windows PE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOCTL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows PE でのネットワーク経由カーネル デバッガ接続方法について</title>
      <link href="/blog/2020/07/29/winpe-kernel-debug-via-network/"/>
      <url>/blog/2020/07/29/winpe-kernel-debug-via-network/</url>
      
        <content type="html"><![CDATA[<p>Windows PE でのネットワーク経由のカーネルデバッガ接続方法についてご紹介します。</p><a id="more"></a><br><hr><p>Windows PE でのシリアルケーブル経由でのカーネルデバッガ接続方法は、以下のドキュメントが公開されております。この方法では、カーネルデバッガを起動する側であるホスト PC を選びません。  </p><ul><li><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/winpe-debug-apps#kernel-mode-debugging" target="_blank" rel="noopener">WinPE: Debug Apps - Kernel-mode debugging</a>  </li></ul><p>対しまして、今回ご紹介するネットワーク経由のカーネルデバッガ接続方法では、通常、以下のブログでご紹介したような kdnet.exe は、ターゲット PC の再起動が必要となるため使えず、予めホスト PC の IP アドレスを Windows PE 側の BCD に設定しておく必要があります。  </p><ul><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/db91ddff-f8ff-49d8-bef2-2a0c596414c2/hyperv-?forum=wdksupportteamja" target="_blank" rel="noopener">Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法</a>  </li></ul><p>それでは、具体的な手順を紹介します。</p><hr><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>今回は、Windows PE のイメージ作成を行う環境と、カーネルデバッガを起動するホスト PC は同じ PC とします。そして、その PC の Hyper-V 仮想マシン (UEFI を使うため第二世代、セキュアブートは OFF) を、ターゲット PC として、Windows PE の ISO を読ませるようにします。  </p><p>ホスト PC には、以下のリンクから、Windows ADK for Windows 10 バージョン 1903 と、ADK 用の Windows PE アドオンをインストールしています。  </p><ul><li><p><a href="https://docs.microsoft.com/ja-jp/windows-hardware/get-started/adk-install" target="_blank" rel="noopener">Windows ADK のダウンロードとインストール</a></p></li><li><p><a href="https://go.microsoft.com/fwlink/?linkid=2086042" target="_blank" rel="noopener">Windows ADK for Windows 10、バージョン 1903 のダウンロード</a></p></li><li><p><a href="https://go.microsoft.com/fwlink/?linkid=2087112" target="_blank" rel="noopener">ADK 用の Windows PE アドオンのダウンロード</a></p></li></ul><hr><h3 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h3><p>(1) [スタート] -&gt; [Windows Kits] -&gt; [展開およびイメージング ツール環境] を管理者権限で起動します。</p><p>(2) copype.exe で、例として D:\WinPE_amd64 に作業用ディレクトリを作成します。<br>(D ドライブの使用は例であり、任意の場所で問題ありません。また、すでに D:\WinPE_amd64 が存在する場合は、コマンドがエラーとなるため、事前に削除しておきます。)</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> copype amd64 d:\WinPE_amd64</span></span><br></pre></td></tr></table></figure><p>(3) 以下のコマンドを実行し、Windows PE 環境側のネットワーク接続でのカーネルデバッグ設定を行います。  </p><ul><li><p>(3-A) Windows PE 環境が UEFI の場合</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\EFI\Microsoft\Boot\BCD &#x2F;set &#123;default&#125; debug on</span><br><span class="line"></span><br><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\EFI\Microsoft\Boot\BCD &#x2F;set &#123;default&#125; bootdebug on</span><br><span class="line"></span><br><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\EFI\Microsoft\Boot\BCD &#x2F;dbgsettings NET HOSTIP:&lt;カーネルデバッガを起動するホスト PC の IP アドレス、xxx.xxx.xxx.xxx&gt; PORT:50005 key:5.5.5.5</span><br></pre></td></tr></table></figure></li><li><p>(3-B) Windows PE 環境がレガシー BIOS の場合</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\Boot\BCD &#x2F;set &#123;default&#125; debug on</span><br><span class="line"></span><br><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\Boot\BCD &#x2F;set &#123;default&#125; bootdebug on</span><br><span class="line"></span><br><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\Boot\BCD &#x2F;dbgsettings NET HOSTIP:&lt;カーネルデバッガを起動するホスト PC の IP アドレス、xxx.xxx.xxx.xxx&gt; PORT:50005 key:5.5.5.5</span><br></pre></td></tr></table></figure><p> <code>PORT の 50005 と key の 5.5.5.5 は例です。</code></p></li></ul><p>(4) 以下のコマンドを実行し、設定した結果に問題ないか確認します。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; bcdedit &#x2F;store d:\WinPE_amd64\media\EFI\Microsoft\Boot\BCD &#x2F;dbgsettings</span><br><span class="line">   key                     5.5.5.5</span><br><span class="line">   debugtype               NET</span><br><span class="line">   hostip                  xxx.xxx.xxx.xxx</span><br><span class="line">   port                    50005</span><br><span class="line">   dhcp                    Yes</span><br></pre></td></tr></table></figure><p>(5) 上記が完了したら、以下のコマンドで Windows PE の ISO ファイルを作成します。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; makewinpemedia &#x2F;iso d:\WinPE_amd64\winpe_x64_debug.iso</span><br></pre></td></tr></table></figure><p>(6) 上記の ISO ファイルで Hyper-V 仮想環境 (第二世代、セキュアブートなし) を作成します。  </p><p>(上記の手順 (3) で、(3-A) で設定を行ったことが前提です。第一世代ですと、UEFI ではないため、(3-B) でないとカーネルデバッグ接続できません。また、セキュアブートは無効にする必要があります。)  </p><p>使用する仮想スイッチは、上記「<a href="https://social.msdn.microsoft.com/Forums/ja-JP/db91ddff-f8ff-49d8-bef2-2a0c596414c2/hyperv?forum=wdksupportteamja" target="_blank" rel="noopener">Hyper-V 仮想マシンへのネットワーク経由のカーネルデバッガ接続方法</a>」の「1. ホストPC と仮想マシンをネットワーク接続します。」と同じものを使っています。</p><div align="left"><img src="https://jpwdkblog.github.io/images/winpe-kernel-debug-via-network/SecureBootSetting.png"></div><p>(7) カーネルデバッガ側は、以下のコマンドを実行することで Windows PE のターゲットにデバッガ接続し、ブレークインできます。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; windbg.exe -k net:port&#x3D;50005,key&#x3D;5.5.5.5</span><br></pre></td></tr></table></figure><br><br></p><p>以上の内容がお役に立てば幸いです。  </p><hr><p><code>変更履歴</code><br><code>2020/07/29 created by Tsuda</code>  </p>]]></content>
      
      
      <categories>
          
          <category> Windows PE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> カーネル デバッグ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>過去ブログについて</title>
      <link href="/blog/2020/01/12/past-blog/"/>
      <url>/blog/2020/01/12/past-blog/</url>
      
        <content type="html"><![CDATA[<p>過去のブログ情報を紹介いたします。</p><a id="more"></a><h2 id="WDK"><a href="#WDK" class="headerlink" title="WDK"></a>WDK</h2><p>投稿数が多いため、全て確認する場合には下記サイトをご参照ください。<br><a href="https://social.msdn.microsoft.com/Forums/ja-JP/home?forum=wdksupportteamja" target="_blank" rel="noopener">https://social.msdn.microsoft.com/Forums/ja-JP/home?forum=wdksupportteamja</a></p><ul><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/521847f9-f90a-4f2b-81eb-3efb57b34152/windows-10-iot-core-com-?forum=wdksupportteamja" target="_blank" rel="noopener">Windows 10 IoT Core 環境の COM ポートの割り当てについて</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/e1979c21-d197-4fb2-a0b4-bb3d2c67337f/wia-wiadriverex-?forum=wdksupportteamja" target="_blank" rel="noopener">WIA ミニドライバーサンプル wiadriverex をデバッグする</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/3842e76b-676d-44ce-b1ae-1ff324b9c3b3/visual-studio-2015-123911239812486124731248832626215172604127861?forum=wdksupportteamja" target="_blank" rel="noopener">Visual Studio 2015 でのテスト署名方法</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/d74842f6-5c05-44ad-b98d-3f26874a5647/12459125401249312523125141254012489-1248712496124831246012391?forum=wdksupportteamja" target="_blank" rel="noopener">カーネルモード デバッガで UMDF ドライバをライブデバッグする</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/06aafefe-ba4c-407e-a4c4-36562d6c6da4/v4-?forum=wdksupportteamja" target="_blank" rel="noopener">V4 プリンター ドライバのデバッガアタッチ方法</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/dd9447a6-6221-407e-9f01-a19b86d77567/-?forum=wdksupportteamja" target="_blank" rel="noopener">デバイスマネージャーの [表示] を [デバイス (接続別)] に切り替える</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/ffae3a15-11af-4ab2-8341-4f004356a6d0?forum=wdksupportteamja" target="_blank" rel="noopener">ダンプファイルに保存されたイベントログを取り出す</a></li><li><a href="https://social.msdn.microsoft.com/Forums/ja-JP/8ff7b651-dcd1-4721-ab34-12c192fa0e4f/12480125311250312501124491245212523123952044523384123731242812?forum=wdksupportteamja" target="_blank" rel="noopener">ダンプファイルに保存された ETW トレースログを表示する</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows Driver Kit 全般 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 過去ブログ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpwdkblog について</title>
      <link href="/blog/2020/01/01/aobut-jpwdkblog/"/>
      <url>/blog/2020/01/01/aobut-jpwdkblog/</url>
      
        <content type="html"><![CDATA[<p>日本マイクロソフトの Windows Driver Kit に関するサポート情報のブログです。</p><h3 id="公開日"><a href="#公開日" class="headerlink" title="公開日"></a>公開日</h3><p>2020 年 1 月 1 日より公開いたしました。</p><h3 id="活動について"><a href="#活動について" class="headerlink" title="活動について"></a>活動について</h3><p>製品のサポート メンバーによって運用されております。仕様に関する情報やトラブル シューティングの手順、実装におけるワンポイント アドバイスを公開いたします。</p><h3 id="留意事項"><a href="#留意事項" class="headerlink" title="留意事項"></a>留意事項</h3><p>サイトのコンテンツや情報において、可能な限り正確な情報を掲載し、更新するよう努めております。しかしながら、状況の変化や情報が古くなることにより、必ずしもお客様環境に適用できない情報となる場合がございます。恐れ入りますが、予めご留意くださいますようお願い申し上げます。</p>]]></content>
      
      
      <categories>
          
          <category> Windows Driver Kit 全般 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> はじめに </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
